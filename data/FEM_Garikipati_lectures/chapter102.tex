\documentclass[10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[version=4]{mhchem}
\usepackage{stmaryrd}
\usepackage{bbold}
\usepackage{graphicx}
\usepackage[export]{adjustbox}
\usepackage{arydshln}
\graphicspath{ {./images/} }

\title{Transcripts}

\date{}

%New command to display footnote whose markers will always be hidden
\let\svthefootnote\thefootnote
\newcommand\blfootnotetext[1]{%
  \let\thefootnote\relax\footnote{#1}%
  \addtocounter{footnote}{-1}%
  \let\thefootnote\svthefootnote%
}

%Overriding the \footnotetext command to hide the marker if its value is `0`
\let\svfootnotetext\footnotetext
\renewcommand\footnotetext[2][?]{%
  \if\relax#1\relax%
    \ifnum\value{footnote}=0\blfootnotetext{#2}\else\svfootnotetext{#2}\fi%
  \else%
    \if?#1\ifnum\value{footnote}=0\blfootnotetext{#2}\else\svfootnotetext{#2}\fi%
    \else\svfootnotetext[#1]{#2}\fi%
  \fi
}

\begin{document}

\section*{ID: krzd3qY68XI}
Hi, for this segment we will be talking about classes in C++. So a class. Is really just a group of data objects and functions. And so we've actually been using classes already in these examples that we've been looking at. The vectors are a class in C++. And you'll notice it's a data object that can store information and it also has several functions that go with it. All right, so what we will be showing you in this segment how to create a class in C++. All right, so there is a basic structure to a class and you would start defining the class in the program before the main function. All right, and here's the basic structure you actually write the word type in the word class and then the name of the class. And then open curly brace and close. Now, as opposed to function we actually put a semicolon at the end of that last curly bracket, okay? Now, within here we're simply declaring what objects and what functions are going to be included in this class, okay? And some of those might be public. So by public, I mean that someone can access those variables from within the main function itself. Some of them could be private which means that you can only access those variables within class functions, all right. So these would be variables, class variables. And functions. Functions can also be public or private. So if a function is private, it means you can only call that function within the class, within other functions of the class, okay. All right, so let's look at that in our code and as an example, so a class like we said a class could be a vectors, it could be matrices could be a class. But it doesn't have to be a mathematical object again. And so in fact it can be pretty abstract. So for an object for an example, class here I'll use the example of triangles, okay. So my class name will be Triangle. And. In my public, some public variables that I would have there or I would have a double defining holding the value of it's space and the value of it's height, okay. Now, what are some functions that I might want like the example we used before, I might want a function that would calculate the area. And so it's the same set appears that I declare the function that here's the output is a double. The function name is area. And as input I actually don't need any inputs because since area is a class function, it already has access to all of the class variables, okay. So it has access to base and height already. All right, so I don't need any inputs. There is a another function that we need, and it's called the class constructor. So a class is just a general description or a group or a type, right? But remember for example, with vectors we would create a particular vector object. So when you actually instantiate an object of a particular class, you call what's called a constructor function. And for the vectors, the constructor it could either take nothing, in which case it created a vector of size zero. The constructor also accepted a size. So we could say vec open parenthesis closed parenthesis of ten and that would create a vector of size ten. The other constrictor for vectors was to specify size and the value in each element, okay. So the constrictor always has the same name as the class itself. So for the constructor for a triangle, we actually want to input the base. And. The height, okay? I'm going to do b and h just to distinguish it from my class variables, base and height, okay? There's also something called a destructor and it has a tilde followed by the class name. And it's used to perform any operations once the class object goes out of scope. So for example, if you declared the object within a four loop at the end of the four loop the destructor will be called. Now, usually we don't need to put anything in the destructor. Occasionally, if you're dealing with pointers you have to make sure all the pointers are cleaned up so you don't have the memory leak. But in this case we're not going to be actually using the destructor, okay. All right, so now there I've declared my class. But now, I still need to define these two functions, triangle, and area. I'm going to rearrange this just a little bit and group all of my functions together just to be clean, get my functions together and the variables together. You'll notice I made them all public. So now, let's declare, let's define these functions, all right? So defining a function for a class is really similar to defining a regular function. But we need to specify that the function belongs to the class that weâ€™re talking about, okay. So to do that first, we start with the name of the class which is Triangle. Then use the double colon and then the name of the function itself. So the constructor has the same name as the class, we have Triangle. Notice that the constructor doesn't have any return arguments, all right. So that's a little bit different. But we still have all the inputs there when we're defining it. And open and close curly bracket, okay? Now in here, what I want to do is assign the value of b, which is an input, to base so I simply say base = b. B is in the scope because it was one of the inputs. Base is in the scope because it's in the scope of the class, okay? And same with height. So I'll say height is equal to h. Now, the constructor is complete. That is all we needed to construct a triangle and to set up all the variables in the class. Now, I will define. The area function. So again, I do triangle :: area, to specify that this is the area function related to the triangle class. We output a double. Notice that this should match the function declaration that we had earlier, okay? Sorry, this function declaration up here. So I'm returning the double of the functioning of area and no inputs. And as before, I return 0.5 or one half times base times height. Again, base and height are class variables so their scope includes all class functions, all right. So I don't need base and height as an input, okay? So that's enough to demonstrate this simple triangle class. All right? So now, let's actually define a triangle object. And just like with doubles ints and vectors, we can declare more than one at a time. So we have tri1, and I'm going to construct triangle one with a base of 1 and a height of 5. And triangle two, I'll do a base of 3 and the height of 2, as an example. So there I've created two triangle object, they're each instantiation of this triangle class. And now, I can use the functions. How do we use it? We use these class functions in the same way we did with vectors. So if I want to calculate the area of triangle one, I would do tri1.area ( ) to let it know that it's a function. Okay. Standard end line. All right. Now, let's run this and make sure I didn't make any mistakes. Make run. And it says, new types may not be defined in return type. And that's because remember when I was on the slide when I wrote out the template for a class, I stressed that there was a semicolon at the end of the brackets and I hadn't put that in here. Let's see if that picks it up and it does. So again, the class declaration. It's a little bit different from function declarations because we need the semicolon afterwards, all right. And so we see that it did indeed print to the screen, the area of triangle one, half the base times the height is 2.5, all right. Now, what does it mean that the variables are public? How do we access those within the main function? Actually do it in a similar way. We do tri1 for example dot and I'm going to say base now, I'm now going to put the parenthesis on remember I said before the parenthesis showed that it was a function without the parenthesis it's looking for a class variable of that name and so I am going to redefine the base. I will let it be 3, okay. And I will call again, after that the same triangle function, the area function. Let's see if that does what we want. Yup, and so in the first it still gave us the area of 2.5, but then when we change the base of triangle one to be three then of course that changes the area. Now, maybe there is a class variable or a class object that you don't want someone in the main function to be changing. And if that's the case, then you would make those private. So let's say we only want the triangles base and height to be defined when the triangle object itself is defined. We don't want it to be changed later on by a user. So we would make base and height private, okay? And so now, we can still use area. Area is public but base and height are private, so if I try to run this, it should give me an error. And what does it say? It says error within this context with tri1.base. There's an error there and above that it says, triangle base is private. Okay, see we're not allowed to access that within the function itself. Okay, now there are a lot of other topics related with class. There's friendship, there's inheritance, there's in addition to being public and private there's protected. I'm not going to go into all of these details with classes. But if you are interested in that again go to c++.com and their tutorials they have some really good information on classes. Now, in our In our coding template for the coding assignments, we actually will be creating a finite element method class that has specific functions related to the finite element method and data objects. So we would have objects such as a global force factor or global stiffness matrix. We would have Class functions excuse me, such as our basis function. Or you might have a function for the assembly process or a function for outputting results. Okay, so this class structure, the structure itself, will be fairly simple. But we will use several variables and functions that led into the finite variable method. So now, we have our class structure here, all in the same dot cc structure here. We can actually separate the class structure into a separate header file and then just include that header file within our main.cc. So let's do that. Create a new File, and I will save it as triangle.h. And I'll save it in the same folder example. And all I'm going to do is copy this class declaration, including the function descriptions. I'm actually going to cut those from n.cc and paste them into triangle.h and save that. And n.cc I'll just do pound include triangle .h. I use the quotes just to specify it's a header file that I created myself, as opposed to a standard header file. All right, so now we go back to our terminal, and we should be able to make run. And it will run correctly just as before giving the exact same outputs and running in the exact same way. So by doing the pound included as if that whole .h file were just written within the main.cc where I included it. Okay? So this will actually be how we give you the coding templates for the homework assignments. You'll have a main.cc and a fem.h header file for each of your assignments. The bulk of the coding will be within the fem.h where you're defining this fem class structure and all the data objects and functions associated with it. And so we'll stop here and this ends these segments on our review and introduction to C++.

\section*{ID: HR9ZGeczCMc}
Great, welcome back. We continue with our development of the finite dimensional weak form. What we have got to doing at the end of the last segment was using the bar unit to mean to not only write out our basis functions. But also to set up the, the integrals that going to the weak form. Okay, so we've written out the integrals that go into the weak form into the finite dimensional weak form for the for the general element by using this this, this approach. And that's where we going to pick up today. All right. So, so the topic of the segment that we are going to work through today is the matrix vector weak form And in order to get to it I, I, essentially I'm going to continue where we were last time, 'kay. Recall that we've written out the form with the following integrals for the, for the case of the general element, 'kay. We've written out this integral. Wh comma x, sigma h Adx for the general element, okay. And it's in your notes, it's in slides corresponding to the last segment. What I'm going to start out with doing is consider this integral for the somewhat special case of element one fueled by the fact that we have a Dirichlet boundary condition on the first node of element one. Okay, so we have this and now let's write con, consider how it works out for e equals 1, okay. Now, for element e equals 1, this is the integral over omega e. W h comma x you recall for element one is written as simply, N 2 comma c, C comma x multiplying c 2 e, where e for this particular case is 1, okay? So this is our expression of W h comma x, all right. It multiplies EA, and then we have our contribution for the gradient of the trial solution. And that takes on the form, sum over B N B comma C, C comma x, d B e, and this is our representation of u h comma x. All right. Integrated over dx, all right. And now of course we take our approach of going to the by unit domain in order to write out this integral. From that we get integral over omega C the first term is, the first factor here is N 2 comma z, we have z comma x, okay. And we recall that, that z comma x is simply 2 over h e, okay. And here we have c 2 e, EA here, and for Comma X we have N B comma C, again, we get C comma X, we use 2 over h e for that as well, we have here d B e. And now, like we did in the previous segment, we're going to rewrite dx as dx we're going to write as d C dx I'm sorry, it is dx, dc, dc. All right now, dx dc we know is he over 2 dC. All right, and as we did in the segment last time, those cancel out. All right. Thus da, a similar sort of exercise for the next integral. Integral over omega e wh f A dx, leads to after going through these sorts of steps we get integral over omega C. Our representation of Wh here is simply N2 times c2e. And remember this is all for e equals 1. Which is why we don't have the contributions from the first basis function, right? We talked about that in the last segment. This multiplying f A, and now in place of dx once again we have dx, dc, right? And we write that as dx dc, dc. And we recall that this is h e divided by 2, okay? So, so we have these two integrals also written out for the special case of the very first element. And you'll recall that what this does is to leave out the use of the first basis function. All right, these integrals here involve only N 2, okay. All right, so we have this in place and what we are going to do now is essentially look at how all these terms contribute, how, how all these simplifications of these, these expansions contribute to setting, setting together the the weak form, okay? So now in order to do that let's consider the general case. Consider for a general element omega e, okay. And let's consider this, the first of these integrals, the integral that comes from the left-hand side, the weak form. That integral is integral na, we now have it written as integral over omega C sum over A, N A comma C, and we write this as C A e, E A sum over B N B comma C D B e. And the term that survives here after cancellations of d x dc, and dc dx type of factors is this one, okay. And we have here dc, all right. Now this needs to be simplified and the way we can carry out the simplification is through several steps. The first of these steps involves us recognizing that the Cs and the ds that are used here are degrees of freedom, right? The Cs is the degree of freedom that is used to interpret the weighting function. The d B sub e is the degree of freedom that's used to interpolate the trial solution, right? So what we do is to recognize that these degrees of freedom are independent. Right? They're independent of the, of the variable of integration, right. They're independent of C, right. Because these are the actual degrees of freedom that are being interpolated by basis functions that are being expressed in terms of c. As a result, we can pull them out of the integral okay, so that allows us to write this out as follows. We can now pull the the summation symbol out. And for the sake of brevity, I'm going to write this is the sum over A and B. Okay? It we get c Ae outside the integral, and within the integral we have a the integrals over omega c. 'Kay, we have here N A comma C EA N B comma C. I'm going to pull the factor of two, which comes here. For the sake of of brevity again, I'm going to put it in here and divide by hE. Okay. So have that factor 2EA over hE sitting inside there. All of this integrated over dc, and that is our integral. Okay. And within those parenthesis, and it is being multiplied by d B e, okay. Recognize any nice, and short succinct form. All right. We have this for this for this integral and let's do the same thing for  the, the integral that involves the forcing function. Okay. That integral is integral over omega C sum over A, N A, C A e, f A, and we get here, H e over 2 dC, all right? Again observing that this is independent of C. Therefore it can be pulled out of the equation. We get sum over A, C A e, integral over omega C, N A f A, and once again I'm going to put the H e here, in this case divided by 2 dc, all right. This is what we have. And now observe that in, in the case of the first element, all right it's going to look very much like this except that the sum over A will not be required, all right. Because A will take on only the value 2. Okay? So, let me just recall this, for e equals 1 there is no sum over A, instead, we have use we, we require to use just the index A equals 2, okay. And why is it that we need to use the index only A equals 2? It's because the first basis function is not used in element one. Recognizing the fact that we have a Dirichlet boundary condition on element one, and therefore, the the weighting contribution from the degree of freedom one is not used, okay? So instead we use A equals 2, because we know that W h at 0 has to be equal to 0, okay. Implying that W h in that element, right? For e equals 1, W h is only written as N 2 c 2 e, okay? All right. So we have this and we're now going to go ahead and construct from this a form of the weak form that we call the matrix vector form. And in order to do that, we need to look at that expression, and that one. The first step to getting to a matrix vector form, of the weak form, is to, is to attempt or, or is to aim to eliminate these sums. Okay? And the way we will eliminate those sums is by writing them out using matrix vector products.

\section*{ID: yeV-8fnoSIs}
All right. So so the idea here is use matrix vector product- To eliminate- The sum, sums over A. And sorry. Sums over A and sums over B, okay? Now, allow me just one second to go back here, and do some bookkeeping, okay? All right. This is where we are. Okay, so let's look at the first of those integrals and work with it. So, what we want to do is write sum over A, B. And here let me write the limits, okay? Because it's useful to remember what the limits are. And with the limits on these sums are, are A and B going from 1 to number of nodes in the element, which for this use of linear basis functions. Gives us number of nodes in the element equals 2 okay, all right? So, we have this cAe integral over omega cNA, 2EA over he, and B, C DC, dBe right? This is the one we want to work with. Now, recognizing that number of nodes in the element is equal to 2, right? Because, we are working with linear based functions and therefore, we do indeed have two of these basis functions in each general element, right? To, to represent both the reading function and the trail solution, right? So, what this lets us do is the following. This can be written now as the following. We recall that since A and B run over 1 and 2, we can easily, we can collect the degrees of freedom, see degrees of freedom into a row vector using the notation of linear algebra, okay? And that row vector is c1e, c2e, Okay? Now, what I will also recognize here is something I could have done in an earlier step. Is that each E of course is a constant, because it gives us the length of the element. In many cases the modulus and the area may not be constant within an element, okay? But for the simplest case, of course, they are constant, and let me pull them out of the integral. By seeing that, let us now focus on the simplest case possible where those are constant, okay? So if they are constant, we get 2EA over he, okay? Integral over omega c, okay? Now integral over omega c. We're, we're going to write it out without writing, without explicitly we sorry. Without using the summation, okay? Instead what we will do, is recognizing that A and B run over 1 and 2, for the use of linear basis functions. We get a matrix with entries N1,c and N1,c and N1,c and N2,c. It's symmetric, but let me write it out in detail here N2,c, N1,c N2,c N2,c okay? That's the matrix integrated with respect to c, right? Now, I use this parenthesis to remind us that this is where the, the absolutely clear actually that that's where the integration ends. Now, just as we wrote c in a vector form, right? Recognizing that the index, here, runs over 1 and 2. We can do the same thing with dBe, right? Recognizing that B also runs over 1 and 2. So that gives us a column vector in the notation of linear algebra, which we will write as d1e, d2e. All right, and I should make a remark here or I should make a note That this holds if E and A are uniform. Over the element omega e. Okay, so for this specific element E that we are writing out this integral, if for it holds that modulus and the area are uniform, we can pull the mod of integration sign which is what we've done here, right? We can pull them out of the integral, okay? He, of course, is just the length of the element and so that, that's constant, all right? In the, in the general case the E and A would still be within that integral and, right? And we would've written functions of of, of c through x, right? But let's look at this simple case, just, just for the purpose of, of gravity and getting to something that we can actually integrate, okay? All right? So, so, this is where we have things, and now we recall what happens for the, for the, for the special case of linear basis functions, okay? Now recall that N1 of c equals 1 minus c divided by 2, and 2 of c equals 1 plus c divided by 2. And that gives us then, quite easily that N1 comma c equals minus half, and N2 comma c equals plus half, okay? So, we can use them inside there. And so, what you are see is that in this case the integration is really trivial. Because the integrant is a constant, right? And this comes about from the fact that we have linear basis functions. This will not be the case when, when we extend this to other basis functions but it's a good way to, to, to, to start understanding how the problem works, okay? So what that says that if we look at what we get from that integral that we started out with it reduces to c1e, c2e 2EA over he. Now, again note that that matrix is, that matrix is fixed, right? It's uniform it's constant over the element. So we base it, we just get here one fourth from the first entry which is this entry, right? Recognizing that it is a product of minus half and minus half we get minus 1 over 4 here minus 1 over 4, and 1 over 4 again. This 1 over 4 comes from the product of one half, and one half, which is from that contribution to the matrix. And so then we just have the integral over on the omega c, all right? And over omega c, dc, right? All of this times our. Column vector of degrees of freedom corresponding to the trial solution all right, okay? Now, we, 'kay, so this is where we are, and what we need to do is evaluate that integral, and that integral, we realize that omega c, in this case, is A, recalling that it's a bi-unit domain. So, I'm going to try and make that look like a straight line okay, that's a little better, straight second, okay? Remember that omega c is this domain. Right, c space, that being the .0, okay? So this integral here is integral minus 1, 21 dc which is just 2, okay? Easy enough. So, putting all of this together, what we get is continuing from the previous slide, that integral that we were working with finally turns out to be c1e, c2e if you look back at your notes. You will see that the, the twos in the numerator, and the one over four in the denominator in the matrix cancel out. And we get EA over he. Matrix is a really simple one. It's 1 minus 1 minus 1, 1. And here we have d1e, d2e. Okay? And recall that this integral came, this integral emerged from us considering, this term, this particular integral in the finite dimensional weak form. Okay? Reduce this to this nice, simple, matrix factor form. And now you can see, why we refer to this as the matrix vector, all right? Just to complete this process let's also work out for ourselves how things pan out for the previous for, for, for the other integral, all right? And that other integral is well I shouldn't say likewise, but sort of similarly. Maybe even similarly isn't right? Let's say in a related manner- Okay? The other interval that we had was the following integral over omega c we had, let me see. What form did we have it in red? We had integral over omega c. We had here a we had here a sum over a cAe. Here we had NA, and fA he over 2, dc, all right? Again, recognizing that The degrees of freedom corresponding to the weighting function can be put into a row vector. And assuming as well again, just for the purposes of writing out something that's easy to actually compute. Let's assume that these two are uniform. Over the element of interest, okay? What that lets us do, okay? So let's see, if these two are in uniform over the element of interest, we can write this also using this matrix vector form. And in this case, we actually just have a simple sort of .product of vectors effectively. So we have this representation for our degrees of freedom and we've agreed that we are going to pull f and A out of the integral, assuming that they are uniform over the element of interest. Again, recognize that the, that they are not required to be uniform. Right, if they were not uniform. If they varied with position over this element, they would stay in the integration, okay? However, we are looking for something that's easier to compute in the simplest of entry level cases, okay? So we have this and now we have integral over omega c. But then omega c, we already know has the limits minus 1 and 1, okay? And then we have NA back here. But using this vector representation we write corresponding to N1 and N2. We have N1 here and we have N2 here, okay? That multi, that dc, right? So, that's the integral we, that we need to compute. And now this is easy enough, because we know that N1 is 1 minus c over 2 and N2 is 1 plus c over 2, okay? So those are the very simple functions, that we need to integrate over the limits minus 1 and 1. Also observe that in here c is an odd, c leads to an odd integral, right? Over the limits minus 1 and 1. So this is actually, this also works out to a nice and simple form, which is we have fA he, divided by 2 here, and that integral from minus 1 to 1 picks up only the constant term, okay? The linear term being odd vanishes, as you probably know from evaluating these kind of simple integrals, all right? So, that's e, effectively an integral over half integral of half over minus 1 and 1. All right, so we get, in both cases we get one. In these two cases we get 1 and 1, okay? And this you recall came from our original integral in the weak form, which had this form. Okay? So we will write that this is our final form for the force, and function too. All right this is a good place to end this segment. When we come back, we will talk about what these matrix vector forms give us further.

\section*{ID: 7PSLJQYi4rs}
All right. We'll continue with our establishment of the matrix vector weak form. Before we, sort of plunge onward, I should just clarify some notation. So I know I used the following symbol. I've been using this symbol I probably said what it means but let me make completely clear, this symbol is since or because. All right, I realize it may be slightly archaic notation that has fallen by the wayside, but I tend to use it still. Okay, so that's where we are. Let's continue then with the matrix vector form. What we did in the previous segment was  write out the important contributions, so, that arise from the weak form for, for it generally, right? And we consider the two main integrals that arise in the weak form from the, the integral that remains on the left hand side. As well as the one  that the one on the left hand side which comes from the stress. And the integral that, that's on the right hand side, that arises from the force and function. We wrote these out for general elements. What I'd like to do now is, take the step of just, sort of particularizing then for the first element, right, because of the fact that it has that tertiary boundary condition. 'Kay, so note that for e equals one. Okay? We have integral over omega e w h comma x sigma h A d x. This is simply c2 e, multiplying EA over he, right? Times let me see, how do we, how does it work out now? Oh right, correct. This times minus 1 1 d1e d2e. Okay, right then and, and you can actually see this in a very simple manner by just taking the general expression for a general element e and recognizing that c1e is not present in the expansion for element one. All right? Likewise, we get integral over omega e Wh f A dx equals, in this case it's just a scalar, right. In fact, well, actually all the integrals do turn out to be scalars when we com, when we complete the matrix vector products, okay. But in this case, we don't even need to use matrices and vectors. So the forcing term is just c2e. We have f A he divided by 2 times 1, okay? So those are the contributions from element e equals 1. All right. What we're aiming to do now is pull everything together. We are going to use the same approach as we used in going from summations over the degrees of freedom for each element integral, except that we're going to now apply that idea to the sum over elements. Okay and in doing so we are talking of the following of the following complete weak form, okay? So yet again recall the finite dimension of the weak form. It's this. Sum over e integral over omega e wh comma x sigma h A dx equals sum over e integral over omega e whfAdx plus, let's not forget this term that we have not had to worry about for quite a while. Right, the term coming from the Neumann boundary condition. So, what we spent our time in doing over the last segment was expressing these integrals, right, in a more compact form using matrices and vectors. So, what we now have is the following. We have the term above implies a sum over e, sum over all the elements. Now, for the general case, we have a form which is, which involves a matrix vector product. So actually let me do one thing. Let me first write out the contribution for element 1. Okay, the special contribution for element 1. For element 1, we have c2e, but e is 1, for element 1. Okay? E A he, but that's h1, okay? Times minus 1, 1, multiplying the vector d1 1, d2 1. Okay. And recall that we write d11 and d21. The super script there refers to the degree of freedom for that element and the subscript refers to the element number. Right? So this is the contribution from the first element to this integral. Right to this integral. Okay, for the the other elements now we have the sum e equals 2 to nel, 'Kay, of c1e c2e EA over he. Times this, very simple matrix. 1 minus 1, minus 1 1. Multiplying d1e, d2e. Okay? So those two contributions, the special contribution from element one and the contributions from that sum e going from 2 to nel, give us that integral that shows up on the left hand side, involving distress. Okay the stress and the radiant of the radiant function. Now, this is equal to all the right hand side terms. And the right hand side terms, also I can write as as follows. Right? Again, as we did for the, for the integral on the left hand side, I will first write the contribution from element one. That contribution is c2 for element 1, times fAh1 over 2, where the h1 reminds us that, that is element one. Plus, a summation E equals 2, 2 number of elements, 'kay. And that summation then is okay that summation gives us c1e c2e fAhe over 2. Okay? All right? We get this contribution. And let me see. Do we oh, sorry. We have fAhe over 2, and we have fAhe over 2 again. All right? Okay. There we go. That's complete. Now the terms we've written on the righthand side are the ones that arise from that integral. Okay, and the term that we could safely not have to worry about when we were writing these matrix vector contributions, is that one. Because that appears only at a single point. It just appears at the point on which we have a Neumann boundary condition, okay? Now, we recognize that that term alone, wh at l, has a very specific, very simple representation. Can you think of what it is? It is c2 for the very last element. E equals nel. Okay? So, the term that we add on here is c2 for the very last element times the data t, which is the rhyme and condition on the traction, times the area, okay? This is it really. This is a nice compact representation of our finite dimensional weak form. This is everything. One thing that may be useful for me to point out here is related to why we get the simple representation. Okay? It's a fairly straightforward thing. And it's something that you may all already have noticed but it's useful to point it out. Okay? So, Remark. And this remark goes all the way back to our representation of in an element as being the sum of NA, let me write NA as a function, expressed as a function parametrized by c, times dAe. And also to the corresponding representation for the waiting function. Sum over b nb c c b b. All right of course it's implied here that x is I've written this on the left hand side. X it's really x parametrized by c, alright and the same thing here. The same thing here as well. Okay. So now, observe that so, so this is of course for a general element, which is written as which can be depicted as this we would have I'll make an e. Here we would have x e you would have xe plus 1. Those would be the global node numbers, right? And we recall that this comes from a bi unit domain. Which is minus 1 to 1, and that is zero. This is omega z. Right? In the one dimensional space parameterized by z. Okay. Now. Okay. So we have this picture. And what I'm going to use it to do is to ask ourselves what ha, what form these, expansions take for and wh. If we choose to evaluate these, quantities, these fields at the nodes themselves.

\section*{ID: o6GfoRWRPfQ}
So, let's suppose that, observe that u h at x equals x e. All right? Is basically u h at x evaluated with C equals minus 1, right? It's the left-hand of the element, right? It's the left-hand side node, which in the omega of C space is represented by C equals minus 1, right? So, this then, is Sum over A. N A evaluated at C uh,1. Right? Because remember, C 1 in the omega of C space is what we identified as being equal to minus 1. Right? So, it's any evaluated at C 1, d A e, okay? But then, we recall that this node, that these basic functions reconstructed had this Kronecker delta property, right? So, this is essentially, the Kronecker delta, delta A 1. Okay? Okay. And therefore, applied to d A e, this becomes equal to simply d 1 E, okay? All right? Essentially, what we've done here is to observe that if we want to evaluate the trial solution at the left node, right? At, it's effectively the first node of this element what we get, is that the trial solution is indeed, equal to the degree of freedom, corresponding to that node. And the same thing happens, if you want to evaluate u h at x e plus 1. This is equal to u h at x with C equal to 1, okay? This is equal to Sum over A, and A C 2, recognizing that C2 is the point C equals 1 times d A e, okay? But then, this again becomes delta, A 2, by the Kronecker delta property of the basis functions.  And therefore, this can apply to d A e, gives us d 2 e. Okay? All right. Essentially, the Kronecker delta property ensures, for us that the trial solution evaluated at the corresponding node is indeed, the degree of freedom value at the node. Okay? Stated differently, the node of degrees of freedom are indeed, the trial solutions themselves. Using these particular basis functions, okay? So and and, the same thing, by the way, happens, of course, with W h, as well. I won't go through the details with W h evaluated at x e is equal to C 1 e, and W h evaluated at x e plus1 equals C 2 E. Okay? So, so the remark here is that, the Kronecker delta property. Then the Kronecker delta property of The basis functions. Right? And by this, we mean the specific basis functions that we're working with, right? The Kronecker delta property of the basis functions ensures That The node of Degrees of freedom, right? Which are these ones, right? Or these for the function, right? This ensures that the node of degrees of freedom of the solution field. Are indeed its values. At the nodes. Okay? This thing, this is sometimes called this, this is sometimes referred to as the interpolatory property of these spaces functions. It is not a universal property of, of arbitrary basis functions. We specifically chosen basis functions, that give us this property, all right? Okay, why did I need to say all of this? I needed to say all of this because it is what we are using here. Okay? We're using it in particular in this to make this identification of W h at L being equal to C 2, for element N here. Okay? All right. So, we have this, okay? And this is the reason, we are able to do that. Okay? Fine. What we want to do here now is go back to what we had when we put together the finite dimensional weak form. When we made all of these observations about, how it can be written out in terms of the matrix-vector products. Okay? You have it on your notes and thanks to the technology here, I have it in front of me, and you can't quite see it. But I can see, that I have it here. Okay. So, what I want you to do is go back to your notes to the point, just before we made the slight digression. To talk about this this Kronecker delta property of the basis functions, okay? Go back to, how we'd written out the weak form, okay? And we are going to work off there. Okay? All right. So, if you look at the way I've written out the, the finite dimensional weak form. Just preceding this this remark, you will see that we are now, able to pull things together from there. Okay? And in order to pull things together, what we need to do, is to observe that there is a mapping between the the degrees of freedom as expressed using local node numbers, and global node numbers. Okay? So, note That The following map Holds Between Local, and global, global node numbers, or, or local, and global degrees of freedom. Okay? I will express this map first in terms of the, degrees of freedom that are used to interpolate the trial solution. Okay? So If we have this particular local degree of freedom, and recall that this refers to local degree of freedom A, in element e. Okay? This can be written as global degree freedom d e plus 1, okay? Let me see. So, d e plus 1. Sorry, it's not d e plus 1 mm, it should be d e plus A minus 1. Okay? So, this let, let me write out in words, what this means. On the left-hand side, I have local degree of freedom A in element Number e, okay? That's what this refers to. On the right-hand side, I have global, Global degree of freedom. Number e, e plus A, minus 1. Okay? Let's check that it works. Always a useful thing to do. All right. So, let's just check, right here. Okay? So, let's suppose we are in element 1, and we are talking of the first degree of freedom. Okay? That would be d 1 1 that is the same on the right-hand side for the global degrees of freedom. d is equal to 1, A equals 1, so we get d1, okay? Likewise, d 2 1 is equal to d e equals 1, A equals 2 minus 1 d 2. Okay? And this goes on. Let's check what happens in the very last element, right? So, when we have d 1 N e L. This is equal to, now, e equals N e L, A equals 1, so we get d N e L, and d 2 N e L is equal to global degree of freedom equals N e L equals 2. We get d N e L plus 1, okay? This works ou,t because if we look at our domain, all right? And this is the very first element. Right? This is omega 1. Right? I will write up here, the local degrees of freedom Right? The global degrees of freedom for this are d 1, and d 2. Okay? For the very last element, which is this 1. Right? This is omega N e L. Local degrees of freedom here are d 1 N e L, and d 2 N e L. And here we have d N e L, d N e L plus 1, right? Makes sense. We have one node more. Than the numbers of elements. Right? The number of the total number of nodes is one more than the number of elements. And that is born out by the way things work out here. Okay? All right. And of course, the same thing holds for the other ones, also. All right? Similarly, we have C e, e equals C e plus A minus 1. All right? So, we've made this the, made the, made the observation about this mapping between local, and global degrees of freedom.  we will use this to go back to that weak form that we had written out. In terms of matrix and vector products over each element. And carry out an important process of finite element assembly. We should probably, do this in the next segment. So, we'll come back to this in just a little bit.

\section*{ID: umrFCEiCf88}
All right, welcome back. We'll continue with the delicate task of assembling our global matrix vector equations. From the specific version that we have of the weak form. And that version the weak form comes from about the code to last slide of the previous segment. You probably all have it before you in your notes and I have it here too, so we're going to start working on that. Okay, so, so we're going to write out the matrix vector weak form. In terms of. Global matrices and vectors. Okay. Okay, for completeness and, because there's just, just one more thing I wanted to say about it, let me just, rewrite the weak form that we have, okay? So, we have the following. We have C21 EA over h1 minus 1, 1. D11. D2,1 plus summation, E going from two to number of elements c1e, c2e, 'kay, here we have EA over he. 1, minus 1, minus 1, 1. d1e d2e equals c21fah1 over 2 Plus the sum, e going from 2 to number of elements. C1e, c2e. In the vector, so you're multiplying, the vector, forming a product, actually, with the vector. Eh, with, with components fahe over 2. Fahe over 2. And finally, we have this contribution from the boundary. C2. Nel times t times A. Okay. This is what we have. Now for again notational purposes, I want to state that in, from the conventional finite element literature, from the traditional finite element literature that matrix, including the factor in front of the actual matrix, is traditionally called the stiffness, the element stiffness matrix. Okay? We will denote it as K sub-e, or with K being a general Symbol use for stiffness. Okay, likewise we can call this sort of a force, this sort of vector the the force for vector for element e, okay, all right, so let me just state what these are called. This thing is called the element stiffness matrix. All right? And, that. It's called the element force factor. Now, of course, when we use terms like stiffness and force, this is clearly a a residual from the times when the finite element method was taught off chiefly as a technique for structural mechanics. Okay? So we will, but, but it's convention to continue to sometimes say element stiffness matrix even if one is doing a problem that has nothing to do with elasticity. They probably, it's, it's in the context of heat conduction it would be more appropriate in to call case sub E, the element conductivity matrix and FE as being the element of heating vector or something like that, okay? But, but this is just terminology that you may see around you in, in various spaces. Okay, so, so this is what we have to do. Now we're going to assemble then. And the process of assembly is the following. Okay? All right, this is called finite element assembly, right? So it's often referred to not just as assembly, but as finite element assembly. All right in order to do this, we recognize that because of the sort of mapping, we. Observed on the last slide of the previous segment. We can write these, degrees of freedom that are used to interpret the weight in function, okay? Into a single global vector. We're going write that single global vector as follows, right? And we're going to write it now using global numbering. Because this is what the mapping that we last looked at in the previous segment, this is what that mapping does for us, okay? So the relevant, global degrees of freedom for the waiting function are C2, C3, right, no commas here. C2, C3 so on up to C and E L, and C and E L plus 1. Okay here, I am going to write, way over here, the corresponding vector of global Solution values at the nodes. Right? Global nodal solution values. This would be the vector consisting of d1, d2, and these are global, okay? D3, all the way down to d n e L, and d n e l plus 1. What I've done here, with this vector on the left-hand side consisting of the Cs is collect the terms coming, like C 2 e, all the terms coming from C 1, and C 2 for each element. What I'm doing with this global vector is, collect the contributions coming from here, and there. Recognizing, however, that when we are writing global vectors, we use the global nodal numbering. Okay? Now, the contributions that then come from stiffness terms such as this, or the stiffness matrix K e can be obtained, or can be written, in a big matrix. Okay? Which I will sketch out, and then fill up. The way we do this now, is to observe that there are contributions coming, for instance. C 2 multiplies d 1, and d 2, because of the contributions coming from element 1, okay? All right? So, those would be the contributions E A over h 1, with a minus sign here, and E A over h 2. Sorry, over h 1, again. Okay? So that's, what we get from element 1. Let's go to element two, right? So, element 2 would have would have degrees of freedom, global degrees of freedom, C 2, and C 3, which would come from, C 1 with e equals 1, and C 2, sorry, C 1 with e equals 2, and C 2 with e equals 2, 'kay? Then did the local to global numbering, the global, local to global mapping of the greater freedom numbers would confirm for us. That the contributions from element 2, as far as the degrees of freedom of the waiting function are concerned, would be C 2, and C 3, okay? Now, those contributions come from the entries to this matrix, okay? Right? So, when we put those together, what we observe is that, we get here a, a, an, an additional contribution. And I realize, that I'm already running out of room here. So, let me just move this over a little. Just move this over to E A over h1 here. Okay? All right. The contributions then coming from element number 2, would be the following. We get minus E A by h 1 from element 1, plus E A over h 2, okay? Here we would get minus, E A over h 2. All right? Down here we would get E A over h 2, the minus sign, and here we would get, E A over h 2. Okay? All right? And then, we go onto element 3. Element 3 would have C degrees of freedom, C 3, and C 4. Okay? It would be this one, and another, and the other entry which comes just next to it. Okay? Those would map onto the matrix, to rows two, and three. Okay, as far as degrees of freedom, from the displacement are concerned. We would have contributions here coming from, hang on. Am I doing this right? Not quite. Okay. We're going to have to back up, a little. Okay? So, I'm just going to Okay. I'm going to erase this stuff. I'm going to go back to some point, and when Okay. All right. I'm, I'm, I'm going to go back even more. Sorry. Sorry guys. Okay. So we would, we, we would have to continue again from the point, where I wrote out assembly, okay? And then, went ahead. Okay. In order to do assembly, we need to assemble the local nodal degrees of freedom, into global degrees of freedom. And the way we do this is with recognizing, that we get here C 2, C 3, so on, up to C N e L, C N e L plus 1. We have for the degrees of freedom corresponding to the solution, we have contributions from the global numbering which are, d 1, d 2, d 3, and so on, up to d N e L, d N e L plus 1. So and here, we will write out a matrix in which we will con, collect the contributions coming from the stiffness matrix, right, from each element. Okay, let's look at what happens with element 1. Okay? Because element 1 has a single contribution as far as the C 2 degrees of freedom are concerned. Okay? It will fill out only the first row, of this matrix, right? As far as the solution degrees of freedom are concerned, it has contributions from d 1, and d 2. Okay? So, if we now, look at the line above us, what we see is that the contributions that come in, are going to be are going to be the following. And, and just for I'm going to pull E A out of this matrix. Okay? All right. So, E A is common for, for all the elements, right? And we, we are assuming that. Okay. So now, what that let's us do, is write out the contributions from element 1, as being minus 1 over h 1. And, one over h 1. Okay? So, minus 1 over h1 is is will, will multiply d1, 1 over h1 will multiply d2, okay? All right. Now, then we go into the contributions that come from that sum, okay? And remember, the very first element that makes a contribution from that sum is element 2, okay? Now, recalling our global, our local to global map, we recognized that contributions that come to that come from the c vector, right, in element 2 are from c2 and c3. This means, that we are going to fill out as far as c2 and c3 are concerned, we are going to be filling out the we're going to be, again, using rows 1 and 2 from this matrix, okay? But as far as, as the contributions from the d vector are concerned, the contributions of element 2 are in d2 and d3. So, this means that we are going to be getting contributions from columns 2 and 3. Okay, or co, contributions to columns 2 and 3 in this matrix, okay? So what we get here then, are we have 1 over h1 here, we get a contribution of the form 1 over h2. Over in the next column, we get minus 1 over h2, okay? In row 2 column 2, we get 1 over h2, with the minus sign, and row 2, column 3, we get 1 over h2. Okay? We go on then to element 3, element 3 has contributions coming from c3 and c4, which is just next to it. Okay? As far as the d degrees of freedom of concern, it has contributions coming from d3 and d4, which are next, okay? So, it is going to occupy it's going to provide contributions to our matrix in rows 2 and 3, and columns 3 and 4. Okay? In rows 2 and 3 the contributions are going to be of the form this, plus 1 over h3, right? So that's row 2, column 3. Row 2, column 4 is going to be minus 1 over h3, okay? We will have row 3, column 3, right? Which will be minus 1 over h3, and row 3 column 4 is going to be 1 over h3, okay? This process continues, all right? Continues all the way down, okay? Until we come to the very last element, the very last element will have a contribution coming from, sorry. The, the very last element, and, and actually, the last but one element are the ones who will contribute to the last two rows, and the last two columns of this matrix, okay? The last but one element is going to contribute a term on the diagonal, here, which will be 1 over h n e l minus 1, okay? All right, the very last element will contribute a term here, which will be this plus 1 over h n e l. I need a little more room, and I think I can get just a little more room by moving this over a little. Okay, so, here we will get a contribution minus 1 over h n e l. Here, we get a contribution, also from the element will be, which will be minus 1 over h n e l, and here, we get a contribution, which is 1 over h n e l, okay? So, these are all the contributions that come from the stiffness matrices, from the yeah from the individual element's stiffness matrices, okay? What I'm going to do is so write then, what I'm going to do is to write this out in sort of, operator notation. Now, what is often done here is, in, in the finite element literature is to say, that this is the result of assembling over all elements, e equals 1 to, n e l, okay? It's the process of assembling over all elements contributions of the form c1 e, c2 e times the stiffness matrix times d1 e, d2 e, okay? This is just an abstract way of writing it, and what is involved in this operator eh, in, in, this sort of an operation, is the detailed sort of book keeping that we followed in, by using the nodal and global degree of freedom numbering, right? In order to fill out this matrix.

\section*{ID: hULDYR9f5So}
With that, we then go on to writing the same sort of a contribution, from the forcing terms. Okay? So the, for the contributions from the forcing terms, we have again, c 2, c 3, up to c N e L, c N e L plus 1. Okay? Now, looking back again at that expression for the finite dimensional weak form, where we've exquisitely, written out the contributions from each element. What we see, is the following. So once again, let's assume that f A is, is f, and A are are, are the same for every element, right? They're uniform over every element, and in fact, they're the same for every element. That allows us to pull f A over 2 out, as a common factor. Leaving us then, with the task of just filling out  this vector, okay? Now, the contribution, from the very first element, okay? If you go back, and look at the, at your notes, would have been h 1. Okay? For element 2, right? We recognize that, element 2 has contributions coming from The c 2, and c 3 degrees of freedom. Okay? All right? And then, if you go back, and look at, at your, at the expression we have, for the forcing function on the right-hand side. You will see, that the contributions here, are of the following form. We have h 1 plus h 2, okay? H 2 coming from, element 2, okay? Element 2 however, also has a contribution corresponding to c 3. So that, goes here as h 2. And then, we go on to element 3. Element 3 has contributions from c 3, and c 4. Which is the degree of freedom, sitting next to c 3, okay? All right. Tthe contribution from c 3, since, we're now talking of element 3, would be h 3, okay? The contribution corresponding to c 4, since, we're still talking of element 3, would be h 3, okay? The process continues, until we reach the last two entries, in this forcing function. Okay? The last, but one entry, will have a contribution from, correspondent to c N e L, but that would come, from the last but one element, okay? And so, that contribution would be h N e L minus 1. Okay? That entry would also have a contribution, from the very last element, h N e L, okay? And the very last entry of the forcing function of, of this vector, that we are trying to develop, would have a contribution only, from the very last element. And that would be corresponding to, that degree of freedom, okay? That could also be h N e L. Okay? This, once again, using this notion of the assembly operation of finite elements, is, the assembly over e equals 1 to N e L, 'kay? Of c 1 e, c 2 e, f A, h e over 2. F A, h e over 2, right? This is the this is the contribution, that we've assembled. And again that, that's just an abstract way, of writing this operation. The detail of doing that operation involves the sorts of the sort of mappings, that we've just used here. To write out these global vectors, from the local ones, and the sum over the elements. All right? Now, there's one more contribution. If you go back, and look at our at our finite element at, at our finite dimensional weak form. You will observe that we have a term that comes, from the traction condition. Okay? It's the one, that we may have actually had on the previous slide as well. Right. On the previous slide, it is this contribution. Right? That comes from the weighting function degree of freedom, c 2 N e L, okay? Right? And we know, how that maps on to the global numbering system, for weighting function degrees of freedom. Right? This contribution then, will appear in, this position. Right? The very last position here. Okay? It will be corresponding to c N e L plus 1. Right? Because c N e L plus 1 is the same as c 2 for element N e L. Okay? So that contribution here, is well we can't quite write it directly into this vector. So, let us then, also write it as, as follows, right? So, we include here, all the c contributions Right? The reason we couldn't write in the vector above, is because we have this constant factor, multiplying that vector. Okay? So instead, we just observe that this thing can be written with a bunch of 0s. All the way, up to the very last contri the very last entry. And for that very last entry, we just have t times A. T being the traction, A being the, the area. And this is just our very simple minded way of writing, c 2 N e L times t times A. Okay? All right. What I'm going to do now, is pull all these terms together, right? And write them up, write them out, in one single expression. C 2, c 3, c N e L, c N e L plus 1, okay? This is multiplying E A. And again for okay. I was going to try, and make some things even easier for us using by assuming all the elements have the same length. But let's, let's not do that, right now. Okay. So, the expressions we have here are minus 1 over h 1. So, shou, so what I am doing here is putting together all the stiffness matrix terms,'kay? Here I have 1 over h 1 plus 1 over h 2. I have minus 1 over h 2 here. Here I have right, I have minus 1 over h 2. Here I have, 1 over h 2 plus 1 over h 3. I have minus 1 over h 3. Minus 1 over h 3. 1 over h 3 plus there is another term, that'll come here from element 4. It will be, 1 over h 4. Okay? That process continues, and when we finally close out this matrix, we will have here. We will have here, 1 over h N e L minus 1, 1 over h N e L. We will have here, minus 1 over h N e L. We will have here minus 1 over h N e L. And here, we'll, we will have 1 over h N e L. I recognize that what I'd written on the previous  when we actually developed this, a couple of slides ago, was a little cramped. Hopefully, this is a little easier to read. Okay? All of these, sorry, this matrix multiplying here, a global degrees of, of freedom. D 1, d 2 all the way down To d N e L, d N e L plus 1. These are all the contributions coming to us, from the left-hand side of our finite dimensional weak form. And they are equal to, terms that came, from the right-hand side, from the forcing function, as well as the traction. All right? And, in order to get those together, let me just go back to this slide, our previous slide. And make sure I save it, so I can work off it, and then, I can come back to where we were. Okay. So, the right-hand side then, involves the same vector that we had up here, okay? The same row vector, c 2, c 3, c N e L, c N e L plus 1, multiplying f A over 2. It's the vector h 1 plus h 2. H 2 plus h 3. H 3 plus, and the dots there will be h 4, but at some point, I do have to just stop writing those, and use dots for extension. And down here, I get h N e L minus 1 plus h N e L. And here, I finally get h N e L. Okay? We have this, and then, we have the final contribution coming from the traction. Again, V f, c 2, c 3, c N e L, c N e L plus 1. Multiplying the vector with 0s, everywhere, all the way down to t A. All right. We are done, with finite element assembly. But we are not done with the, with our final sort of tweaking of this of the equations. There is more work we need to do here. But the big task of assembly is done. We'll stop the segment here. When we return, we will come back to these matrices to, to this general matrix factor expression. Make some observations about it, and turn it round to the final form, in which we will actually solve, the problem.

\section*{ID: VweAq9waOY}
Hi. In this segment I will introduce you to the Deal.II website, and then we'll look at a way of running your code on your own machine, using a virtual machine through Oracle Virtualbox. All right, so let's go to the screen now. We'll actually go first to the Coursera website. And if you scroll down, on the left there's a resources tab with links to different websites and other resources. So at the very top is the deal II website. It's actually just a dealII.org with the two as a double i. There are three things I wanted to show you about the deal.II website. The first, under 8.2.1, which is the current deal.II release. We'll go to Tutorials. The tutorials are really just example programs, and if we scroll down you see a graph or a schematic of how the different tutorials relate to each other. They sort of build off each other and become more sophisticated the higher the numbers go. We'll go to number eight, which is elasticity, which is something that you'll be coding yourself at some point. Although it will be a little bit different format. Now, I really like the way these tutorials are set up. The first part of the tutorial, as you can see, goes through the underlying physics and the governing equations involved. Can see it gives a pretty in depth explanation of what's going on and what you will be modeling, or what they are modeling in this tutorial. It also gives relations to other tutorials and where you might want to take it further. The next section is what's called the commented program, and as you can see it has comments, paragraphs of explanation interspersed with the code itself. All right, explains the header files, the templates that are going on, the different function names and so on, as well as the DOT data types, okay. So that section is quite long. So I'll scroll down. It also goes over the results, but then at the very end is the plain program. So if you just want to see the code itself, here it is at the very bottom. So you can look through it and see what's going on. There are several of these programs, these example programs, these tutorials. They're really helpful especially if you want to move on, beyond this course and use deal.II in your own research, or for your own work. This is really helpful for learning deal.II on both a simple and an advanced level, all right. Go back to the deal.II website really quickly here. The other thing I wanted to show you, or one of the other things, is the download page. We actually won't be expecting you, or you won't need to download deal.II and install it on your own machine, but if you do want to, this is how you do it. You can install it on Linux and that would be this first archive file, this tar.gz file, you would download it to your Linux computer and here are the instructions for installing that. It's actually really simple to install it on a MAC. Here are the binary packages, and the instructions there. Another option that deal.II has on their website, is a virtual machine image, and I'll go into that a little bit more. We actually won't be using deal.II as a virtual machine image, because it doesn't have the HDF5 library installed, which is necessary for creating the hallmark submission file. So actually, if you're going to be installing this on your own computer, whether it's a Linux or a Mac machine, you'll need to make sure the HD5 library is installed. If you want to run it on Windows, there may be ways to do it by creating a Linux environment, such as Seguin, using Seguin. But it's probably going to be easier to use the virtual machine that I'll be talking about in this segment, or AWS, which I'll be talking about in a future segment, all right? The third part of the deal.II website that is extremely helpful, is their documentation on the deal.II classes and functions, such as the deal.II vector, the deal.II full matrix and so on. I actually usually don't access that through the deal.II website itself, initially. I access it by going to a search engine like google, and searching deal.II vector for example, and it's usually at the very top of the results. Okay, so here is vector class template reference, and at the top of the page shows how the inspector class relates to other classes. That can be pretty extensive with things like full matrix. With a vector it's a little more simple, and then it goes through the public and private member types and data types associated with the vector. So it goes through the different constructors, the functions like reinit explains the different operators involved. All right, so there are quite a lot of functions here, and if you want to know how to use one more in depth, or a more in depth explanation, just click on the link. It scrolls down to the right spot on the web page, okay. And deal.II's documentation is really good, that's one of the reasons we decided to use deal.II with this course, okay. So those are the three mains things about the deal.II website that I wanted to show. Of course there's more to the website than that and feel free to explore. All right, but now I want to shift over and look at the virtual machine. Okay so to do that, we'll go back to the Coursera website under resources again. We'll be using this virtual machine through Oracle's VirtualBox. So here's the link to download that. It's an application that you can use on Linux or Windows or a Mac. Whatever type of operating system you're using, you should be able to use VirtualBox, okay. It's a pretty, It's pretty straightforward to download and install. It's not a huge file. It doesn't take up a lot of space on your computer, by itself. Okay, but once you've installed VirtualBox, you want to go back to Coursera, and you'll download the virtual machine appliance. Now this is what has all of the software that you'll be using, okay? And it's a Linux appliance, it's an Ubuntu virtual machine, okay. It's a .OVA file, so you would just click on this. It would download it. As you can see, it's 2 GB, so it's a pretty big file. I'm not going to download it again to my computer. It can take quite a while, depending on your internet connection, okay. But once you've downloaded your .ova file, then you would go to VirtualBox, which you already have installed, and you'll open that up. I've already imported the appliance to my machine, but I'll show you how you would do that on yours. Go up to file, import appliance, and then you would browse to where that file is downloaded. So here it's in my downloads folder, press Open, and next would take me to the different settings. Okay, you shouldn't have to change any of these settings, probably, and then you would press Import. Now it would take about 20 or 30 minutes to import, so I won't press Import again here. I'll just press Cancel, but again, of course you would press Import. Okay, now once it's imported, your screen will look like this, okay? So you press Start, and it can take a little while to bring up the screen. Okay, and the first time it's running here for you, it may come up with this error, like it does for me, it says implementation of the USB 2.0 controller not found. I just press OK, and I go to settings making sure of course that virtual machine is selected still. Go down to USB and I'll deselect enable USB 2.0 controller. Press OK, and now I'll go back to start. So again, this is an Ubuntu virtual machine image, and so, as it comes up, you may not need to use it but the username and password will be Ubuntu. So, if you ever need to use it as a super user, using as you do. It does take a little bit for the screen to come up. Okay, so we're loading xubuntu now, and even though it's a small screen now we can make it full screen so that it's, as if you're actually working on a new Ubuntu machine. It is a virtual desktop here and everything is actually located right on your own laptop. So you don't need an Internet connection once everything's installed, and again this works with Linux, Mac or Windows. Now after it's installed, the virtual machine appliance does take up a fair amount of space on your hard drive, something like 7 or 8GB. So you will need about that much space on your hard drive in order to use this option. So you can see it is its own desktop, I'll switch to full screen mode. It has its own web browser here, so Chromium. You go up to the top left, is where you'll access the different applications. So actually the web browser here doesn't work. You go over here to the right to Internet, and then you can go into Chromium, go to development, and you have Emacs for a text editor, for editing your code. Let's see, Accessories. Leafpad is also a text editor, but it's not necessarily meant for editing code. It is there though, it's quite a bit simpler than Emacs. Another thing is you have an archive manager, because your co-template will be downloaded as a .zip file. So you can use Archive Manager to unzip your files, and then remember when you're submitting your homework files you will be creating a zip file of all the submission files. So again, you can use Archive Manager to do that. So everything you need to do for your homework you can do right here within this virtual machine. Because you have the text editor, you have the webpage or the web browser, you have the archive manager. You also have VisIt to visualize your code. You can double click that, and it opens up the GUI. Okay of course, so now the main thing that you need to know how to do on here is how to run your code right? So up here as well, you would go to Terminal Emulator, and here you have your terminal two actually run your code. Okay so do ls. So we'd want to, for an example, I'll go into the deal.II examples, so it's cd deal.II examples, and here it has step one and so on. These correspond to the tutorials that we saw on the deal.II website. So if go into the step-8, you can see it has CMakeLists.txt file and a step-8.cc. So the first step to run your code is to do cmake and then CMakeLists.txt and press enter, so this will create a make file, that's specific to our .cc file to our source code okay? So now if I press ls, you can see that it's created several different files including this make file, and the make file will compile and run our code so I can do make run, and it will run step-8 for us. It does take a little bit of time, just to compile your code, even if it doesn't take a long time to run it on the virtual machine. It does take a little while to compile it and link everything. It's finally linking and running it for us. Okay, so now if we list the files. You can see it created several VTK files which you could open up and visit and look at. All right, and when you run your code you'll be doing something similar, you'll have it a schemiclist.txt file as well as some source code. Of course you'll be editing the source code, and you'll be running it using Cmake. Okay, so that should be enough to get you going with the virtual machine and in the future segments we'll be talking about how to run your code using AWS.

\section*{ID: QnSxLO-f1-c}
In this segment, we'll talk about how to use Amazon Web Services, AWS, to run your deal.II code, okay? So let's go over to the computer. And first we'll talk about getting set up with AWS and loading the AWS, the AMI. Okay, so first you would sign in, you go to aws.amazon.com, and then sign in. You can use your existing Amazon account, or there's an option to create a new account there. All right. You can just choose the free account. So now once your to the Amazon Web Services, your main page here. You'll go up, at the top left there's a link called EC2 virtual service in the cloud. And we're going to launch an instance. Okay? And to choose the one that has deal-II installed, we'll go to Community AMIs. And you can just search for deal-II, double I. Okay, and you can see that this is the only machine image that has deal.II installed. If, for some reason, there was more than one, you would choose the one that's ami-93217fa3, okay? That's the one that's been created for this class, at this point, at least. All right, so, we'll select that. And I'm just choosing the free tier, the T2 micro, and I'll launch that. Okay, now here you have to create or choose a key pair, so that just links this instance to the key pair that you will download for your own computer. So, it's just a security measure. So I could create a new one. You can choose that here. You could create a new key pair. I've already created one. So I just called it deal-II-key-pair. You can name it whatever you want, and I acknowledge I have access to it. Okay so I'll launch the instance now. And it's associated with that key pair. It's a file on my computer. Okay. So I'll go and view the instances. So now, it's been created or it's creating. You can see right now it's still pending, it's initializing, all right. But that's all you need to do to get set up with AWS. The next step is to access it. Now, it doesn't create a virtual desktop like the virtual machine did that we talked about in the previous segment. So, in order to access AWS, we'll be going through SSH or something like SSH, okay. All right, so you can see here that the instance is running. I'm running Windows right now, and there are a couple ways to access AWS through Windows. I'm going to show the easier of the two first. It's easier if it works. Okay?  So depending on your situation it may not actually work. So the one I'll show you first is the second option. A java SSH client directly from my browser. So, as it specifies, Java is required. So, when I tried to run this on Ubuntu with Chromium, it doesn't work, because they're not supporting Java anymore. I have to use Firefox. However, right now in Windows, Chrome is still supporting Java. Okay so, for username we actually change from root it becomes ec2-user and that this will be the same for you no matter how your log in to AWS, okay. Notice it automatically has the keep hair that I specified before. And it saved the file path right where I have saved it before. I had to put that in the first time, okay? So, you'll, when you do this for the first time that won't be there. Okay, you'll have to type it in. Okay, and remember to include the name of the keeper, the file name. Okay, and you can store it in browser cache if you want to. And then it will save the file pathway. Okay then press Launch SSH Client. And most likely it will come up with this warning. Application blocked by Java security, it's because they haven't, AWS hasn't updated one of their certificates. And so if you want to use this in order to use it on your computer you'll have to add this website to the whitelist in Java. So you notice I went to the start menu. I have configured Java here already. But, if you want to you can type it in down here in search, configure Java, and select it there, okay. And it brings up the Control Panel. So what you do is go to Security. We're on High security. And then you do Edit Site List, and you can add the the location that it has listed there. So, I'll type that in. Now, hopefully, they will update their certificate soon. So we don't have to worry about putting it on Java's whitelist, but, okay, and that matches. We can press OK. And that's set up. So, after we change the setting in Java, after we add this site to the whitelist, then you have to close out the browser and then reopen it, okay? All right, so, after we've added this website to the whitelist on Java, we'll close out the browser and open it back up. And go to aws.amazon.com, sign back in and go to EC2. Now, we want to see our instances. We've already created the instance in the Machine Image. So, we'll go to instances  and click Connect. Now we should be able to choose this Java client. Then we need to change the username, again, to ec2-user, and then my, I actually changed where I put this key path. It should be in Example deal-II-key-pair. Let me just go there really quick, under C, Example, and right there, deal-II-key-pair. Delete that file, because we'll be talking about it later. Okay so now, and I will store that in my browser's cache. Launch the SSH client.  And it comes up with this security warning. I accept the risk, and I do want to run the application. And it will bring up in just a second. There it is, okay. And now it's brought up this terminal that accesses AWS. All right, and so it's all ready to go. We can do print work in directory. And you can see we're in the home ec2. Dash user, directory, do ls, and there's a desktop folder, and an x example folder. All right, so now we're able to run it. We can, for example, go into the example folder, and it has these same examples that we saw on the virtual machine. Okay, again this correspond to the tutorials that's going to step eight. And I did already run this, but just to show you again the process we do C make, CMakelista txt to create a make file. And once you have the make file, you can do make run, and it will run. Again, this is a elasticity code, and it will create several VTK files. All right. Recreate them, in our case, since I already had ran it before. All right. So, there it's pretty straightforward on now it's using this is just like having a terminal open in the virtual machine, or on your own computer. If you had the installed on your own computer, so just like using a terminal there. All right? But again, since this is just a terminal, you can't. It doesn't have a way to visualize, it doesn't have a way to edit your files, so in order to do that you'll have to copy, or transfer your files to and from AWS to your own computer. With this mind term, which is the Java application here, it's really straight forward. You go up to the top here, Plugins. And then there's SCP File Transfer, click on that and it's very easy. You can choose for example, a file on my computer so I'll go to C and example. And let's see over here on ECT user. I'll make a new directory called example. So now, it's there, I'm going in to that, and let's say I want to copy main.cc from my own computer to AWS. Just press the Celero and it copies it over. Done, okay. And I can go the other direction too, with the other arrow. All right. If I wanted to. All right, so it's very straight forward very easy to use. Once you have Java set up to accept this application, all right. And again hopefully Amazon will change that certificate since so that we don't need to put it on the white list to make it work. All right. So that's one option. However if changing the settings on Java perhaps isn't an option for you on your computer, or you're a little concerned about the security risk there, there is another way to connect. And that's using the, this first option choose a standalone SSH client. Now for Windows, we can use what's called PuTTY, and here's a link here that explains how we would connect using PuTTY. All right? So, I'm going to minimize this screen a little bit. So that we can keep these directions on the screen. Okay so the first thing is to install PuTTY. So we have the download. It gives us a link to the download page here. I'll pull this out into another window for us. All right, and again there are two options here. I'll go to the download page. You can download it itself, actually install it on your Windows computer. And that would be down here, putty-0.63-installer.exe. Executable. So, you could download that and actually install it on your machine. However, if maybe you're not, not your own computer, and you don't have installation privileges on the computer, then we can do it another way. There are three other executables that we want to download. There's PuTTY,exe. There's PSCP. You remember when we were using we used the SCP to transfer files. So, this is PSCP. So, it's the PuTTY's, we have using SCP, and then PuTTYgen. PuTTYgen will convert our key pair from the .pem file to a file type that PuTTY recognizes, okay? So I've got these three files, these three executables, in my Downloads folder. Okay, so now you can exit out of that. And we'll look back at the directions. Now these other directions are information about our instance. So I'll X out here. So for example we will need the main thing that we'll need here is this public DNS address. Okay? So let's go back to the instructions. We also need to know where the private key is. That will come up. Okay? All right, so first let's just connect to AWS using PuTTY. And then we'll talk later about transferring files. Okay, so the first thing is to convert the private key type. Okay, so here I'm in this example folder, which is where I have my deal-II-key-pair.pem. I'm also going to open up my downloads folder And you can see here, puttygen. Okay, this is an executable, so I can just run it, I don't have to install. Okay, so I need to go to Load. Again, these instructions are on the web page, website here. So, it says, Start, PuTTY(gen). If you'd installed it, then you could just go to your start Start menu and type in PuTTY(gen) and run it from there. Okay, we downloaded the executable, and so that's why we just double clicked on the file in our downloads folder. Choose SSH-2 RSA, and then we go to load. And, again, it's here in example. It went there automatically. Choose all files, and then we choose the .pem. Okay, so it successfully imported it. We'll need to save private key. You can see that's the next step here. Save private key, and I'm not going to do a pass phrase. And I am going to just rename it, or name it the same as my .pem file. However, it is a .ppk file, a putty private key file, now. All right, so I'll save it there, and that's ready to go. I can exit out. Now to actually start a PuTTY session, We'll go to, again I'll go to my Downloads folder. If you did install PuTTY, then you would go to the Start Menu and find PuTTY there. I'll just double click on PuTTY and run it. Now let's look at the directions here. So in the Host Name we entered user-name@public-dns-name. Okay? So our user name is ec2-user, that's going to be the same for all of you. Then @, now we need to go to the instance. Okay, and you'll notice that this public DNS has the public IP. It's the same address there. So I'll copy that into the Host Name. Go back to the instructions,you'll see it says to make sure that the Connection type is SSH and the Port is Port 22. All right, now, over here in the Category pane, we'll go down to Connection, and then we'll expand. Press the little plus sign on SSH, then select A-U-T-H. All right, authentication. Now we need to find our key pair, and now it's this .ppk file that we created. So we press open and then that's the last thing, now we just need to press open again to start our PuTTY session. Okay you, again, you can save the host key or not. I'm not going to in this case. It doesn't matter too much. And now we have, again, this terminal open so that we can access AWS. Exactly the same now as it was in my intern, just use the command line. Commands, you can see we have already, we still have that Example folder that we created from line term because AWS. Saves the files when you exit out. Okay, so you can see we even still have main.cc. I'm going to delete that for now though. Okay. All right, so, that's empty. Okay, so now we need to look at how we would transfer files to and from AWS. Okay, since we won't be editing them trom this terminal, okay? So you'd be editing your files on your own computer and visualizing your output files on your own computer. All right, so let's scroll down a little further on the instructions. And it talks about transferring files. There are actually two ways. I'm just going to talk about using the PuTTY SCP that we downloaded. If you're more comfortable with using a GUI, Then you can download this WinSCP, and the instructions are here, but I'm not going to go through them with you, okay? But that is an option. All right so, now to use this PSCP, we're going to open up a Windows Command Prompt. So, you can type that in here at the Search, type in command and then choose Command Prompt. And for those of you who've used SSH on Linux, or. On a Mac, this will be very similar to using SCP on a Windows, or a Mac. Or, on Linux, or a Mac, excuse me. Okay, so the first thing is we need to specify that we're using PSCP. Okay, now, again, if you installed it using the installer, you would just type in pscp, which is what it says here in the instructions. However, we didn't install it. We just downloaded the executable, so what we need to do is actually type in the file path. So, for me it's in . You can press Tab, and it completes the file name, okay? And then the name of the executable is pscp.exe, okay? And then next, we just type in the minus i, -i. Now, first I'm going to. Well, whether we're transferring from the computer to AWS, or from AWS to the computer, the next step is the same. Now we need to specify where our key pair is. So then I put that in my example folder and it's called deal-II-key-pair and again we used the .ppk since this is PuTTY. Now for this first example, I will transfer a file from My Computer to AWS. So, first I'll specify where that file is and I'll use the same example of passing main.cc, okay? All right, and now I need to specify where I'm transferring it to, specifically, I need to type in my username, ec2-user@. Again, I need to do, I'll just right-click and Paste. Okay, again, that's the DNS that we used before to access PuTTY. Okay, and I'll do a colon, and then I will put in the file, or the path to where I want the file to go. Okay, so that's home/ec2-user, and that would be the same for everyone, and I want to put it in that Example folder, okay? So now if I press Enter, it hasn't seen this key before. So I'm going to press yes, store the key in the cache. And now it transferred it. So if you go up here to our PuTTY terminal, and we do ls, you can see that now Example has this main.cc file in it, okay? Now, to transfer the other way, it's going to be very similar. We're going to press up to get back to that previous screen. Okay, very similar. So, again, the first part is just to type in where pscp.exe is, if you didn't install it, -i. Then, again, the path to the key pair. Now, I want to transfer. I'm going to transfer that main.cc back from AWS to my own computer, all right? So I will do the same. It's essentially the same command, only switching the last two. So first, I'll do this ec2-user@ a DNS. Paste that. And I want to copy the file home/ec2-user/example/main.cc, okay? So that's the file of origin, and I want to copy it to. My example file here, and I can actually rename it if I want to. I'll name it main2.cc, just to distinguish between them, okay. I press Enter and okay it says there's a problem here, cannot identify. It's because I was using a backslash instead of a forward slash. So that's something to watch out for. Windows directories use back slashes, but Linux uses forward slashes, so I need to use forward slashes here in my file path, okay? All right, so now that should have transferred over, we can go to our folder here and there it is main2.cc, okay? And so once you've know how to transfer your homework files, your .h, ,cc, and .txt over to AWS and then you can run it on AWS. Once you got your output files, you can again transfer those back to your computer to visualize them. All right, so that should have you set to use DO2 on AWSC3 using mine term for Java or using PuTTY. On the next segment, I will talk about using SSH to access AWS from Linux, and it's also the same on a Mac.

\section*{ID: AjTCdB-51MA}
Hi. We made a small change to the AMI, that we use on AWS, that we made available to you on AWS. And so I wanted to show you three changes that you'll need to be aware of as you're accessing the AMI as you're using AWS. All right so the first thing to notice or to be aware of is that AWS is split up into regions. All right, so here I'm the top right of your page here on the EC2. I can even go back here to the EC2 dashboard. You'll notice there are several different regions, 9 different regions, spread out throughout the world. So you'll want to choose a region that's closest to you probably. That will work the best for you. So I'm choosing North Virginia, for example okay, and now we want to launch an instance. Okay, and we go down to community AMI's, this is just as I showed you before, but because we changed the AMI a little bit, it's going to have a new number, and also, each AMI is specific to the region that it's in. So the AMI for north Virginia will have a different number than the AMI for Oregon or Ireland, for example, okay? So we'll have a list of the regions and their corresponding AMI number on the Coursera website for you, all right. So you'll have to look there to figure out what AMI you'll be looking at. You'll still probably be able to just search for DL2 within that region and select that. But again, if there's more than one DL2 image, or if for some reason in the future we rename the AMIs, to something that's not DL2. You can always refer to the Coursera website, look up that AMI number for your specific region, and search for that number, okay. Now the other thing that changed, so those are the first two things to be aware of, the region that you're in and the AMI number. The third thing is that we switched the Linux type for the AMI, whereas before it was an Amazon Linux. AMI now it is in Ubuntu AMI just like the virtual machine, and so whereas before you were always using EC2 user for the user name, whenever you were connecting to AWS through SSH. Now the user name will always be Ubuntu, and we'll have more reminders of this on the Coursera website. But again remember, whenever you're using SSH to go into AWS for these new AMIs, the username is Ubuntu, and I'll show you an example of where that might come up okay. So I will go back, to my instances. For example here, I already have one running and I'll click Connect, and one of the options that I'll be showing you more within this segment is the standalone SSH client, or this Java SSH client, and here the default user name is always root. But again, you want to use Ubuntu, and that's the same, whether you're using SSH on Linux or Mac, or if you're using Putty on Windows to SSH to use the AMI on AWS.  Excuse me. Okay. So those are the three things that I wanted to make you aware of. The region. The AMI number and the user name is now Ubuntu, all right.

\section*{ID: KW-w3Hu-3uU}
Hi, in this segment we'll talk about how to access AWS using Linux or Mac through SSH, and how to transfer files as well. So let's go to the screen. Going to aws.amazon.com. I'm assuming you've already set up the instance like we talked about in a previous segment. I'll sign in here and go to EC2. The top left of our screen, And that will pull up our instance. So, on the left we choose Instances, And this Instance is selected. Going to minimize the screen for a second. Now we press connect, all right? So this gives us some really plain instructions for how to connect, Through SSH, okay? So first I'm going to go to the folder that has my key pair in it, which is my Documents folder. All right, and now the first, or I guess step number three, it says to do the chmod 400. This is to make sure it's a private key and not public, or that it's not publicly viewable. Type that in, just as it has written. And nothing shows up, which means it worked. All right, and so now the next step is to type in the command that it shows under example. And we'll just make one small change, ssh -i deal-II-key-pair.pm, but our username is ec2-user, not root. So that will be the same for all of you. And then I'll type in the IP address, okay? Press Enter. And now we're logged in. So pretty straightforward on how to connect to AWS though SSH. Okay, you can see all of our files are there. Still have Example. Oops, cd Example. And we have main.cc in there, I'm going to delete that. And then we'll transfer that over again, Using SCP. Okay, so now we're all set up through SSH, but we do need to be able to transfer files back and forth, all right? So I'll click down here on connection documentation and it'll pull up another page. And click on Linux using SSH, and scroll down to transferring files. Okay, so first you need to have an SEP client, which you probably already have. Okay, so I am going to open up another terminal and we'll use these directions. Okay? This step one is optional. So we'll go to step two. Step two says to change directories to go where your key pair is located. So we could do that. I'm going to do it another way. I'm just going to stay in my current folder and then just specify the file to my key pair. That's just another way to do it. So we type in S-C-P dash I, and since I'm in Linux, since I'm using Linux, I can use this ~/ to specify my home directory, Documents/deal-II-key-pair.pem. Okay, so that specifies the location of my key pair. Next, we specify the location of the file that we want to copy. So first, I'm going to copy the file from my computer to AWS. So, that's in Desktop/Example/main.cc. Okay, now I need to specify where I want it to copy to. And so that will be on AWS, so I'll use my username ec2-user, at now I need my public DNS. So I can close this out and scroll over so I can see public DNS. I can copy this address. Okay, Ctrl+C, Ctrl+Shift+V. And then colon, and I'll specify the file path on AWS. So again, I can do tilde to specify the home directory and I want to put it in example. Press Enter, and there, it's copied over. We can look at our SSH terminal and you can see again we have main.cc on our AWS instance. All right? So now let's copy that back just to show you how to copy, for example if you've run your code on AWS, you have some .VTK files you wanted to visualize. So, this is how you would copy them back to your own machine to visualize them. So we'll still do the same scp -i and give the location of the key pair, documents/deal-II-key-pair.pem. Again, that's the name I'm using. Whatever name you've given your key pair, of course you'll put that in there. Now, I want to copy a file from AWS. So I'll type in, I'm essentially just switching the order from the previous command. So ec2-user at my public DNS. The file is in Example/main.cc, and I want to copy it to my Example folder on my Desktop. And just to distinguish between the two files, I'll call that main2.cc. Hit Enter and it's copied over. We can open up that file, and you can see, there it is, main2.cc. All right, so now you are able to copy your files back and forth on Linux, or it'd be the same on a Mac, and also run your code on AWS. So now we have a couple different ways to run DL2 either through AWS on Mac and Linux using SSH or on Windows using PuTTY or Mindterm. Or we could use a virtual machine on Linux, Mac, or Windows. All right, so you should be all set up now to run the example code or to run your own homework files using DL2.

\section*{ID: Fy0zdJQvTbI}
Welcome back, we continue with our development of the finite element equations. At the end of the last segment we got as far as looking at the individual integrals in the finite dimensional weak form, the weak form and writing them out as matrix vector products, okay? This is where we're going to pick up today. The topic of this segment at least is going to be the finite element equations in matrix vector form. Okay, now, what I'd like to do here is, perhaps, just recall the forms the integrals. Okay, so, we saw that when we put everything together, we had, for this integral, integral over omega wh, x sigma h Adx. We had the following, we had the rho vector of degrees of freedom corresponding to the weight in function. And this began with this particular entry, right, C2. C3, in terms of global degree of freedom numbers, right? This went all the way until we came to Cnel + 1, okay? This was multiplied by EA. And then, we had this matrix, which I'm going to try to write out really neatly today. So if I recall correctly, in this position we have -1 over h1. In the next we have 1 over h1 + 1 over h2. And here we ought to have had -1 over h2. In this position, we have -1 over h2, and here, we have 1 over h2 +1 over h3. Here we have -1 over h3, -1 over h3. Here we have 1 over h3 + other terms and I'll stop because if not I will, I won't have a suitable point to stop, okay. This continues all the way down until we have in the very last position here, the very last little sub matrix, sub two by two matrix. We have 1 over hnel -1, 1 + 1 over hnel- 1 over nel and here finally we have 1 over hnel- 1 over hnel, okay. And this matrix is closed here, and okay. I'm going to multiply this by a row vector, okay, because I've run out of room there. I'm going to write to row vector down here. Sorry, the column vector down here. This column vector has global degrees of 1, 2, all the way down to dnel + 1, okay? And let's just recall that this goes up here, okay. This is what we had for our integral on the left-hand side, all right? For the integral on the right-hand side, which as you recall comes from the force, we had the following. The integral itself was integral over omega whfAdx. And this, when all was said and done, also was multiplied by the same c vector. Up to cnel + one. And multiplying it here was fA, and let me see. I think I add an fA, perhaps, over 2. And the contributions here were the following. We had in the very first position, we had h1 + h2. Next position we had h2 + h3. And so on. Up to, in the very last two positions, we had hnel- 1 + hnel, and finally here we have hnel. Okay, all right, we had this and then we have the very last term, which was an easy one to write. The last term was Wh(L) tA and this following the same convention that we've adopted. For the other terms was multiplied by the vector of C degrees of freedom. Which is probably the waiting function degrees of freedom going all the way up to Cnel + 1. And the vector that it was that that rho vector was multiplying, the column vector here was filled with zeros all the way up to the very last entry. And at the very last entry we had tA. Okay and I realize now that for all the h's here, for all the element lengths, I used super scripts. Up to now, but the first two slides of this segment have been using subscripts. We'll go back to superscripts, but let me just put in a remark here, so that if you review these lecture you will note that as well. We're using h sub e here instead of h sup e and we're now going to go back to h sup e, okay. More photos on the next slide. Okay, so we have these terms here and what we want to do now is to begin assembling them. As a first step what I'm going to do is just to get a little more insight and make it a little less unwieldy, I am going to say that we are going to consider the case where all the element lengths are the same. The development so far and especially the form we have on the previous slide on this one and what we've done in the previous segments should convince you that method is completely applicable to formulations where or the measures where the elements do not have the same lengths. Just for some sort of gravity in writing and convenience and some on my defense side as well, I'm going to say all the HEs are the same, okay. So let me just make this remark also here. Consider he constant for all e. So there's a single h e we don't need to distinguish h1, h2 and so on, all right? It just makes things a little easier to write. So now if we go back and look at the matrices we've put together, what we should observe is something about the sizes of these matrices, okay? So we'll do this, but now we're going to use common element lengths. Okay, note that the finite dimensional weak form that we have with all these matrix vector expressions is essentially this. C2, C3, Cbel, plus one, times EA. Now, because we have a common element link, just for convenience I'm going to put it out. Again, this is what I wanted to achieve as well. Okay, this now multiplying the matrix which has the form minus 1, 2, minus 1, minus 1, 2, minus 1 and so on. Okay, until we come all the way down here to 2 minus 1, minus 1, minus 1, 1. Okay, all of this now multiplying the displacement degrees of freedom. If we're doing an elasticity problem or more generally the solution degrees of freedom, right. The trial solution degrees of freedom, okay. This is our entire left hand side of the weak form equal to on the right hand side, we have C2, C3, Cnel+1, fAH over 2. And now again because all the H's are the same we have here 2, 2, all the way down until we have a one in the final entry, okay? Plus C2, C3 Cnel plus one multiplying zeroes everywhere in this column vector until we come down to ta, okay? So for the special case of a mesh where all the elements have the same length HE, we have this nice simple representation, right? And that's an HE there as well. Okay, what I'd like to do here now is just pay some attention to the. Sizes of the relevant vectors and matrixes should be completely clear of course it's pretty much written here the way we've written out the scroll vector. That this scroll vector has dimensions in year, so of length and year. Right, simply because it's going from two to nel plus one, right? This column vector here is NEL plus 1, which leads us to conclude that this matrix is of a dimension NEL cross NeL + 1, okay? Essentially, the same thing on the right hand side tells us that this column vector, as well as that one, are off length NeL. And like and of course this is the same, the c vector is the same one, right. Right so both of these are off length Nel. Right, obviously just for consistency of the matrix vector products. Now. So we have this form and let's see what else we know about it. Can you recognize what we know about one of the degrees of freedom in the vector of nodal trial solution values. So look at that vector, the D vector carefully and think of what we know about at least one of those degrees of freedom and in fact one of those degrees of freedom. Because of the chronicle delta property of our basis functions, we've demonstrated that this particular entry, right Is actually use zero, not right, and that comes about because you remember what our mesh looks like. Right so this is element one and this position here is X. This node is X 1 equals zero. On that node the degree of freedom is D 1 which is U zero. Okay, which is a node Right? Because it's R, the traditionally boundary condition. Right? What this tells us is that when we look at the matrix vector product on the left hand side of this matrix vector equation, we can actually take this entire column, right, and I'm going to do something which is a little not strictly legal. But I'm going to draw that column vector, right. And because of the nature of this matrix, okay? Sorry. The other entries in this column vector are 0. Right, all the way down. Okay? All right. Essentially what we can do now is because we know d1 equals u0, right? And we recognize that this particular column vector that I've marked out in the matrix, is the one containing matrix elements that multiply D1, which is equal to U0, which is known, we are at liberty to actually move it to the right-hand side. Okay. All right, so what we will do here is, okay, is the following. We are now going to write this as C2, C3, CNEL plus 1, EA over H E times the matrix now that is considerably simplified, well not considerably, but at least somehow simplified. Two minus one, minus one, two minus one, going all the way down to minus one two minus one. Minus one one. Okay and the diagonal is this one. And the upper and lower diagonals of those ones. Okay. This thing multiplying the vector now d2, d3, all the way down to dnel+1 right? = C2 C3 up to CNEL + 1. Now multiplying, I'm going to put all the column vectors together here, okay? The first column vector is fAhe over 2. Multiplying twos all the way down except for the very last element which is one. Plus another column vector filled with zeroes all the way down to the very last entry which is T times A. And now there's a newcomer to the party here, right? The column vector that we looked at here, I'll draw yet another arrow to it, can be moved to the right hand side. Recognizing that we have a minus one in this entry, okay, we have on the right hand side, EA over HE multiplying D1, but D1 is known right D1 is known to be equal to U not because of two things. Because of the tertiary boundary conditions, as well as though the chronicle delta property of all basic functions. Okay. Now when we look at the size of our matrices, we recognize that really it's just this is the only one that we need to correct because it's lost a column. Early it had nel rose and nel+1 columns, so it has now lost a column, okay? So and we are going to recognize therefore that it is a matrix of size nel cross nel. Okay. And we're going to do one more thing. We are going to call, so nel across nel is the dimension, or rather the dimensions, of this matrix. And we are going to write this as the matrix key. Likewise for obvious reasons we're going to regard this vector of degrees of freedom for the waiting function as the vector c. Since all our vectors are we like to think of vectors as being column vectors and recognizing that we've written this a a role vector, I'm going to call it c transpose. A vector is terminology that we reserve for column vectors. Likewise, this vector, again for obvious reasons, is going to be my D vector. Okay, here again we have our C vector and now I'm going to look at all of this, right? All of these contributions together and call them my F vector. Okay? I just recognized this c vector again is a c transpose, again using this idea of row and column vectors. Okay?

\section*{ID: 01LvqvKwHrU}
Let me pull all this together and write it in a very simplified manner. Okay, so what we have here is c transpose Kd equals c transpose F. Okay. This is close to the final form of our finite element equations in matrix-vector form. Okay? But there's one other important step we need to take here. Which is, to recognize that this vector of weighting function, degrees of freedom, actually does interpolate the weighting function. Right. So recall that in each element, we had wh of e equals sum over A, NA cAe going back just briefly momentarily actually to our local element numbering system for the c degrees of freedom. Okay. Also recall that our weak form, our statement of the weak form is the following, right, in much abbreviated, in a much abbreviated version it was defined belonging to S such that, St is short for such that. For all wh belonging to V, and I'm sorry, these are both, that's Sh and Vh, right, right? For all wh belonging to Vh the following integral holds, the following equation holds, right? So this is our weak form again, yet again. Okay. What we've done now is essentially reduced that integral weak form to the equation at the top of the slide. Okay? In matrix-vector form. All right? So, and let me, yet again, state that here. All these statements, while, while a little superfluous, are repetitive definitely, are useful to drive home points. So we, we make them repeatedly. All right. So, that is our matrix-vector weak form, and the important thing that I want to point out is that this holds for all wh belong to Vh. My question to you now is that, what is it in the matrix-vector weak form that represents wh? Remember, using basis functions, finite dimension basis functions, we've gone from this integral form at the bottom of the slide, the last equation on the slide which involved fillings. To matrix-vector form which involves just degrees of freedom for matrices for vectors, and we have entries for matrices. So in that setting, what is it that represents wh? Okay? Essentially, what represents wh is the following. This equation of ours is completely equivalent to our statement at the top of the slides. C transpose Kd equals c transpose F. When we realize that this has to hold for all c, right? Belonging to this R nel space. After all is just a vector with nel entries, okay? It is when we specify that our matrix-vector weak form must hold for all c, right? Because all c belonging to this nel degree of sorry, this nel dimensional space that we are essentially imposing the same requirement as we do here. Why is this? It is because the c of degrees of freedom which interpolate the weighting functions. If our weak form has to go for all weighting functions belonging to Vh, we've already fixed the functional form of Vh by choosing particular polynomial basis functions. All right? Or by choosing certain basis functions. That degree of arbitrariness which must still hold within the space Vh is insured if we require, that the matrix-vector weak form holds for all c belonging to this nel dimensional space. Okay, well, but if this is, if this is the case, it is clear therefore that this can only hold if Kd equals F. There's a formal way of demonstrating that, and this just involves moving everything to the left-hand side, and then considering what forms c can possibly have, all the forms that c can possibly have and discovering that this must be the case. Okay. We can make that, that rigorous argument if you need to, if we need to, but I think it's pretty clear why, why this works. Okay, so, this is the final form of our final, for, for our finite element equations, okay? FE short for finite element. Right. Remarks. Okay. The first remark I want to make is that the matrix K that you have in front of you or probably in your notes is symmetric. It's positive definite. Okay. Furthermore, it has abandoned, so-called tridiagonal structure. With  banded, tridiagonal structure. Okay. The symmetry comes from the fact. Symmetry from the fact that the term of the weak form which gave rise to our matrix K has this sort of structure. Right? Where this is our stress. Okay. So if you look at this integral as a as an object called a functional in w and u. It is bilinear, okay? Furthermore, it remains unchanged if we just swap the places of w and u, okay? Right? So the reason this thing is symmetric is because we have this term in the weak form and we could very well interchange those two positions, right? Wh and. Okay? This is what makes our final K matrix symmetric as well. If we were working with a different set of equations which, for some reason, did not give us this form of an integral where wh and could be interchanged, and still have the same meaning, right? And, and still have the same integral, then we would not have a symmetric matrix K. Okay? Oh, of course, I should also state that now K, again for obvious reasons, is called a stiffness matrix. Okay, and as you might imagine this is related to the fact that when we look at it in, in the form Kd equals F which you have before you it is reminiscent of a of a spring. Right, K being the spring stiffness, d being the displacement of the spring and f being the force on the spring. And indeed, in the early days of finite elements when there was a lot of structural mechanics work done with finite elements, this was the, well this was the right interpretation, okay? But now if you, if you imagine that you're doing a heat conduction problem, you would probably would, you would probably, properly call it something else maybe the conductivity matrix, right. But traditionally, it's called a stiffness matrix. So let me just put that in quotes. Okay now, the other bit is the positive definiteness. The positive definiteness comes from the fact that our in this particular case, our so-called material constant, E, is greater than 0. We didn't actually state that but if E and D is greater than 0, then we have a positive definite system. All right the particular banded tridiagonal structure comes from the fact that there are two first order derivatives, and that we have a linear set of basis functions. Okay, so. The bandedness is actually is, is included when I say tridiagonal. So tridiagonal from. Single derivative on wh and. All right, in this form that, that's before us in the integral, okay there's a single derivative on each of them. And from the fact that we have a linear basis functions. Okay. The next remark I want to make, and really it's the final remark of this segment, it is the fact that our force vector in this case, I'm just looking back to my notes here to make sure that I have, oh, there we go. That I have here before me, so that I don't make any errors in putting in back up here, okay. Our force vector in this case is the following. It's fAhe over 2, times 2 being all the way down to 1, plus 0 all the way down to tA, in the last entry. Plus EA over he, multiplying our Dirichlet boundary conditions u knot, and zeros all the way down. All right, there are a few things I want to point out about this. If we look at this contribution to the force, to the force term, it comes from the distributed forcing function that was specified at every point along the bar. Right, our original function, F. Right, which we assume is a constant in order to get this final form. If F were not a constant, it would be inside this it would be within this the column vector here. Okay so, so one thing to note is that if we consider the mesh and consider a stretch of the mesh with elements of that type. Okay? What we're seeing is that the contribution on a node, which has elements on either side of it, is of the form fAhe. Okay? It's only the very last element. Right? This is the point L. Okay? It's only this very last element which has a contribution, fA. So at this very last node which has a contribution fAhe over 2. Okay? And this is really because an interior node has a contribution fAhe. It sort of has the entire force on it. Because it has elements on both sides. So both those elements contribute force to it. However, this last node has a contribution only from the element to its left. Okay? This is pretty obvious. This contribution is from the traction and it's no surprise that it appears only on the very last node, because that's where the traction is indeed applied. This contribution is also very important one. You recall that this came about from the fact that Dirichlet boundary condition is known and therefore that degree of freedom in the d vector in our trial solution vector could be moved over to the right-hand side. Dirichlet b.c for boundary condition. 'Kay? So what this is giving us is the loading, right, on the problem, obtained by specifying a Dirichlet boundary condition, okay? So this is what you may call within quotes, a Dirichlet driven load, right? You, we, we all very well know that partial differential equations can be driven by either the Dirichlet or Nuemann boundary conditions. This is how the Dirichlet boundary condition itself drives the problem. Of course, in the kinds of problems, we are considering, the sort of boundary value problem we're considering, u knot was typically zero. Okay? So that actually drops out. But in the context of elasticity, what it does for us is give us the effect of the, the, the, the, the load that gets transmitted to the structure. Because of the fact that on the left end, at the left end of the structure, we've fixed the displacement to be equal to zero. Okay? So let me say just one more thing here. This Dirichlet driven load is equal to 0 in the considered case. Okay. So there we have it. The various contributions to the, to the effective forcing on the problem, coming from the distributed forcing function from the traction, the, the Neumann boundary condition, right. Since I'm calling it traction, I also ought to say that this is the Neumann boundary condition, and finally, the effect of the Dirichlet boundary condition as well. Okay, we will stop this segment here, but essentially at this point we have completed our simplest finite element problem in 1d for linear elliptic equations. Okay. Well, I should, I should also state one more thing, right. I've just said it's formulated the problem. What is the solution? Since we have Kd equals F, the solution is d equals K inverse F. Okay, that is the formal solution. Of course, you may or may not actually invoke K depending on the size of your problem, that is an entirely separate question which we don't get into here. This is just the formulation. Once we have d, of course we can then go back and reconstruct in any element as being simply the interpolation over A using the bases functions, which we know very well, times dAe. Okay? So we've recovered the actual field from the solution. Okay, here's where we definitely do stop the segment.

\section*{ID: Nrwrd8DLPG0}
So, there was a question on, the definition of symmetric and positive definite matrices. I realized that I had neglected to define them so, here we go. So. A matrix K is symmetric. Right? Matrix K is symmetric if K equals K transposed. Okay. What this does for us is that in the context of the kind of, views we were putting this matrix to, it means that if we consider our vector C, okay, so if N we can compute C transposed K d. This turns out to be exactly equal to d transpose KC, right where d and C are vectors as defined in the previous segment, okay. So this is what we mean by seeing a matrix as symmetrical. Okay. Now, a matrix is positive definite. Positive definite. If, right, and once again let's use the same matrix key. Okay, the matrix key is positive definite if, let's do the following, if, first of all, let's, we, we need to pay attention to the dimensions of K. Okay, so let's do what we had here. Let's suppose K is an n plus n matrix, all right, and the problem we were looking at we got an NEL cross NEL matrix, okay? All right, so if K is an n cross n matrix then it is positive definite. If, and for all d belonging to Rn, right, for our n dimensional vectors. We have d K d d transpose K d is greater than or equal to 0, okay? In particular, okay. In particular. D transpose k d Is greater than 0 if the vector d is not itself the 0 vector, okay? The 0 vector is simply a vector with 0 in every single entry. Okay? And then what that means, of course, is that therefore if K is positive definite, then d transpose K d equals 0. If and only if, so IFF means if and only if, okay? D equals 0. Okay, so essentially, the, the notion of a positive definite matrix is in, is a generalization to matrices of the notion of a number being non negative. Okay, so if a number or a, or a variable can be either only positive or equal to 0, but never negative, then the equivalent definition of a matrix is, positive definite. Well, actually, that's, that's not strictly right. It, it, it is the generalization of of a variable being positive. Okay? That's what makes, that, that is equivalent to a matrix being a positive definite, okay, but anyhow, that, that is just an interpretation, the important bit is this these, the, this definition. All right, we'll stop here.

\section*{ID: hDDEtp70YcI}
Hi. In this segment we will begin looking at the coding template for the first coding assignment which is homework two. All right. So, before we look at the code itself, think to yourself about what are some of the functions and data objects that you'd want to include in your C plus plus program. All right, think about that on your own for a minute. Okay? Now, let's write down some of those. First, we would have our basis functions themselves. Right, so those would be the functions that are interpolated for you to create your finite element solution. And along with the Basis Functions would also be the gradients of the Basis Functions. If you look at your first assignment, you will also see that another function that we need to create is a function that will calculate the L2 Norm of the error between the actual solution and your finite element solution. So that's another function that you will need to create. Now how about the steps of the finite element method? What are the different steps that we go through? Well, we have to generate a mesh. Or import a mesh of some sort. Right? We need to create F local and K local At some point. And once those are created, then we have to assemble F local and K local into the global stiffness matrix and the global forcing vector. All right, and then we also have to define and apply our boundary conditions. Now those can be Dirichlet boundary conditions or Neumann boundary conditions. Okay. And after that's created have K and F, then we have to solve for D. So we have to have some function that solves, for D. So D = K inverse F. And then you'll probably want to output your result somehow into some format. Alright, so these are some of the functions that we would have. Some of the data objects themselves, what we've already mentioned here, would need our stiffness vector, or our stiffness matrix, K. We need F and D as well. Our foreseen vector, and our solution vector. We would need some sort of object that would relate our local degrees of freedom to our global degrees of freedom. Sometimes we call that a connectivity matrix in general. Although it may not actually be a matrix so I'll just call that a connectivity object. We, of course, would need some sort of object that actually stores the information in the mesh, which would be related to this connectivity object. So, I'll include that here in mesh. All right, there may be others, too. We'll look more at that now as we look at the code, okay? So let's move over and look at the code itself. As we told you in the homework file in the homework description, we're giving you two homework files. There's the .cc which is the source code and a .h file which is the header file. The header file is what includes your finite element class. All right. So, that contains the bulk of the programming. But to begin with, let's look at the main .cc which is the main program that's running. All right. So, here you can see I've included some standard C++ header files, but I've also included this FEM homework to template.h. That's your header file that includes the information about the class. And here on line 12, you can see that I said this using main space deal.II. Now the reason for doing that is because we have a lot of deal.II objects and normally, we would have to type in deal.II, double colon, and then the name of the data object. Just like with standard. For example, standard vectors we type in SDD::vector. If we instead wrote using name space standard, then we wouldn't have to do the standard colon colon every time we wrote vector or c out, for example. In this case, we're using namespace deal.II. All right. And then our main program. Okay? This first part, it just has to do with some of the mechanics going on. Our program really starts here. First we define the order of our basis function. That will be an input to the class constructor. Here I have order equals one but again for the first homework assignment, it can be linear, quadratic or cubic. Okay? So either order one, two, or three. Also there are two parts to the homework problem, part one and part two. And so again that's also an input. The only difference between part one and part two is in the boundary conditions. Problem one has two Dirichlet boundary conditions and problem two has a Dirichlet and a Neumann condition. Alright here on line 25 is where we actually declare our object. The name of the class is FEM. It's a templated class and all I'm going to explain about that is that there is a template parameter that goes into the class that the functions and data objects are based off of. In this case it's the dimension. Okay, so I put in a one here between the angle brackets. Just specify that it's a one dimensional problem that we're working on for this homework assignment. I'm naming it problem object but again that's just a name I'm giving it, it's not the class name, it's just the name of this particular instantiation of the class. And again the inputs are order, the lagrounging basis function order and the problem number. All right, so now we get into some of the actual functions. Remember, in order to call a function for a class, we first include the name of the object and then a decimal and then the name of the function. Alright, so the first function that I'm calling here is generate mesh, and as an example here I am inputting 15. That just tells, or this is where we specify how many elements we want in our mesh. So in this case I am saying a 15 element mesh, of course you can change that. In this case, with the way I've set it up, this will make 15 equal elements. Okay, all the elements are of equal length. Then I call this function, called setup system. Of course this doesn't really come in from the finite element method, but it's mostly for initializing our data objects. Resizing the force vector, the solution vector, the global stiffness matrix. That's also where we will be setting up, or defining our quadrature rule. We'll decide how many quadrature points we need per element, and then we define what those points are and what the corresponding weights are. After that is assemble system, and it's within assemble system that we actually create K local, F local and then assemble those into the global stiffness matrix and the global force vector. All right. We've previously defined the Dirichlet boundary conditions within setup system, the Neumann boundary conditions, you'll see we define as we're creating F local. And then we actually apply the Dirichlet boundary conditions within assembly as well. Solve is a very short function that simply solves for D equals cambers F. Here, I am outputting to the screen, the L2 norm of the error. For this, for the given basis functions, and for the given number of elements. And finally, we output results. We output results as a .vtk file. And for the linear problem, there's actually not much to see, since it's just a straight line. But when we move on to the 2D and 3D problems, then I will show you how to open up one of those files, in a visualization tool, called ParaView. Okay? So let's move on to the header file. Now scroll to the top here.  Now in the comments you see at the top. I've specified that anywhere you actually have to make a change or modify the template I've included the word edit in capital letters, okay. So, anywhere you see edit you'll have to edit something, otherwise you can let it be. Also, as you're writing your code don't change any of the function names or inputs that I've already set up for you. You are, however, free to go ahead and create new functions, or additional functions, if you find that helpful. So there are a lot of header files here that you can see in the code. And almost all of them are DO2 header files. We actually won't necessarily be using all of them in these first homework assignments, such as quadrature point. We'll be creating our own quadrature points, we'll be creating our own basis functions. However as the class goes on, in the last two homework assignments you will be using more and more of DO2's actual functions. Okay. Now let's scroll down to the declaration of objects. So I've created everything as public, so that means we can access all of these objects and functions from main.cc. All right, now to begin with here's our constructor, and we've already seen this constructor in main.cc. We have as an input the order, the order the Lagrangian basis functions, again, that's one, two or three. For this homework assignment, of course it could go higher if you chose. And then the problem, again that's part one or part two. Here we also have a class destructor. No inputs to it, but you will see that there is something going on in the destructor. Now, here we get to the functions that I've set up for you. The first function is a function called xi-at-node. And I'll explain a little bit more what that means when we get down into the actual definitions of the functions, here we're just declaring them. But it has to do with, the differences in the local node numbering between DL2 and what we've seen in the lectures already. So this function will help you get the value of xi using the DL2 node numbering. Here we have our basis function and basis gradient. And now down to the solution steps. We have generate mesh, which we solved before already. Define boundary conditions. That's actually called from within setup systems, so that's why we didn't see that in main.cc. Then again setup system, assemble system, solve, and output results. And again, after that, we have the l2norm-of-error functions. So those, the rest of those are functions we saw already in main.cc. That concludes the functions. Now, we have some class objects. These first three are objects, are DO2 objects that they've, that they've defined and we're declaring them here. Triangulation basically stores the mesh. FE and DOFhandler have to do with the connectivity, keeping track of the degrees of freedom, as well as general basis function ideas going on. Okay? Now we get into our own data objects. And these next three have to do with the Gaussian quadrature, that we'll be using to perform the integrals, that occur in K local and F local. All right. So the first is an integer called quadro. It's just the number of quadrature points. In your element. Now, you'll have to decide how many quadrature points, and we'll look at that a little bit more later. And then we define what those quadrature points are, again in 1D, and the corresponding quadrature rates. All right. So, it's an integer and then the next two are standard vectors of doubles that we've looked at before, in our review of C++. Okay. More data structures. The first one is a sparsity pattern. And we use a sparsity pattern with our global stiffness matrix, K. Because as you remember from the lectures, most of K are zeroes. And so, when we're dealing with a large stiffness matrix it doesn't make sense to store a lot of zeroes and so we use what's called a sparse matrix and it only, it essentially stores just the non zero components of K global okay. Sparsity pattern is what keeps track of where those locations actually are in the real, in the full matrix itself, okay. We have a vector of doubles, D and F, that's our solution, solution vector and our global force vector. You'll notice this isn't a standard vector. It's a DO2 Vector. There's a capital V. And so the functions related to vector, the DO2 Vector are a little bit different than the standard vector. And mostly we use that in our solve function. When we're solving for the solution vector D. Okay. Now, I have this standard vector of doubles called node location. This is a vector that just gives you the x coordinate, okay, and the real domain of each global node. And then, a map. A standard map called boundary values. Let me give a little more information on the standard map. This is a C++ data object, the standard map. And as you can infer from the input there, you have to define two data types. In my case, in this case we've defined two number types. This first is an unsigned int, and the second is a double. And so this basically just, as you might expect from the name, it maps an unsigned int to a double in our case. One big difference though from a vector, is that a vector, in a vector the indices start at zero and they just go sequentially up from there. So zero, one, two, three, and so on. With a map, what you might call the index, doesn't have to be sequential. So in a standard map, the standard map of boundary values. So we have a standard map of unsigned int, and that should be. Let me erase. Should actually be an angle bracket. Okay. Unsigned int and double. Called boundary-values. Okay. So in boundary-values, we will be relating the Dirichlet boundary node number, the global node number, and the actual value. So, if we have, if this is our domain, and we're breaking it up into elements. Let's say at the left we're applying a Dirichlet boundary node of g1 = 0 and at the right we're playing a boundary node value of, a Dirichlet boundary value of g2 = 1. All right? So all we need to, and I'll let these be our global node numberings so I'll just go sequentially, zero, one, two, three, four, and five. So in boundary values we want to store the node number, with the Dirichlet value. So the node value is an unsigned int. The Dirichlet value is a double. Okay? And so all we need to do here is we do boundary-values. The index, this first term, you can think of as an index. And so at node zero we have a boundary-value of again zero. Alright so there we've defined that, we've set that into this boundary values map. On the right, at node 5, we have an applied boundary condition of one. Okay, and so now, whereas in a vector we would have had to have a vector of length 6, in order to have an index of 0 and an index of 5. With a map, a standard map, this only, if you were to do a boundary-values.size, it would return a size of 2, because we're only storing two values in this map, okay? So let's go back to the code. After the boundary values map, I've defined several doubles. There's the basis function order, problem, or prob. Those again will store the Lagrangian order that we're using and the problem, part one or two. Then I have L which is the length of the domain. G1 and g2, which again are the Dirichlet boundary values. G1 at the left and g2 at the right. Okay, now under here, solution name array, these are just vectors that have to do with the output, so you actually won't be dealing with these at all. Okay. Let's stop this segment here and in the next segment, we'll start looking at some of these functions themselves.

\section*{ID: FmCG-MbeGOw}
Okay. We will continue with other aspects of our finite element method. We're sticking still, with our linear one dimensional elliptic PDE. But what I want to do now, is take the opportunity to go to the case, where we could have a problem, a boundary value problem. where all the boundary data are specified as Dirichlet data, 'kay? So, what if there is no Neumann data? Okay. So, we will call this segment pure Dirichlet problems. Okay? Or just, Dirichlet problems. So, in the context of what we are doing here, the statement is the following. Find U h belonging to S h, which is a subset of S, where S consists of, all functions u such that u, and 0 equals u not, and u at L equals u given, okay? Now, since, S h is a subset of S, what this implies, of course, for us, for our finite dimensional weak form is that S h consists of functions u h. Now, they could belong to H 1, right? Like we have considered for our finite dimensional weak form. When we consider Dirichlet, and Neumann data, okay? So, u h belongs to H 1, and omega, such that, u h, and 0 equals u 0, and u h, at L equals u g. Right? That's the kind of u h, we want to find. Okay. So, find u h of, of this form such that For all w h belonging to V h, and just for consistency, with whatever the problem, we do this properly. V h is a subset of V which consists of all functions w, such that, w at 0 equals 0. And now, w at L, also equals 0, okay? So wherever, we have Dirichlet data, the weighting function satisfies the homogenous Dirichlet condition, okay? And then, this implies for us that V h consist of all functions w h, also belonging to the space H 1. On omega such that w h of 0 equals 0, and w h at L, also equals 0. Okay? Okay. So, essentially, we're saying find u h belonging to S h, where S h consists of functions that have that are H1, and have Dirichlet data on both ends. Okay? Such that, where all w h belonging to V h, which now, consists of functions satisfying homogenous Dirichlet data. Right? At x equals 0, and x equals L, 'kay? Okay. What needs to hold? Well, the same old weak form. Integral over omega w h comma x sigma h A d x equals integral over omega w h f A d x, and we are done. There is no Neumann data, right? There are, there are no Neumann boundary conditions in, in, in this problem. So, we don't have the contribution from the traction, right? This is it. Okay. Essentially, the formulation is the same, as we've studied for the Dirichlet-Neumann problem. The only detail is what happens with our homogenous Dirichlet conditions, on the weighting function, okay? So here is the picture actually. So the physical picture, if you care for it, is this one. Right? At this end, we know, that we have u not. Which we know, we are thinking of, as being equal to 0. At this end, we have not a traction condition. But we have that displacement, if this is an elasticity problem, is equal to some given value. Right? Alternately, if this were a, heat conduction or a mass diffusion problem. It would say, that we would be saying, that we have to the temperature specified, at both ends, right? Or maybe the concentration specified, at both ends. Right? And we have of course, our forcing. Right? This is f. Okay?  Sorry. All right. This is our forcing, in this direction. Okay. Right? So, so this is the physical picture. Now, we proceed just as before, right? Let's assume that we have a decomposition of the domain, a partition of the domain, into our elements. Right? And the subdomains which are elements. That would be omega 1, that would be omega N e L. Okay? Now, observe that what we are saying is that because of the form of our Dirichlet data, at both boundary nodes. We are going to do something special about the weighting function, basis function, the basis functions for the weighting function, in elements omega 1, and omega N e L, okay? So, what this implies is that As far as basis functions go. Here again, let's suppose that we are working with linear polynomials Over You know, these are polynomials that compact support, right? Just as before, all of that is the same, right? Over each element omega e, okay? So then, what we're saying is that w h in element e equals 1, is equal to only, basis function 2. Okay? And, and our basis functions 1, and basis function 2 are exactly, the same as before. Okay? So, we take only basis function 2, function of c through x times c 2 e equals 1. Okay? And the same sort, well, the similar sort of thing, holds for element e equals N e L. Okay? This one is, which one, which basis function do we use, for element N e L? Remember, that this element is this one. Element 1 is this. Right? And so, what we're saying is that for omega h, we use only that basis function, right? In element 2, sorry, in in element 1. Element N e L on the other hand, is going to be this one, right? I jumped ahead of myself, by also drawing the basis function, right? But you get the idea. That is a basis function, the only one that we will use in element N e L. Okay? So, this one is just N1, c 1 e equals N e L. Okay? So really, this is the only thing. This is really, the only difference. Now, when we go back, and look at our the integrals contributing to our weak form, okay? So, we get the following, okay? Integral over omega w h comma x sigma h A d x equals, now, when we work things through, what we will see is that, we get in element 1, we get c 2 1, okay? Multiplying e A over h e Minus 1, 1. And here the co, the column vector is d 1, for the element 1, d 2, for element 1. Okay? We get the usual summation over all the L, over the remaining elements, e equals 2 to N e L mi, minus 1. Okay? I'm sorry, I should Got too close to that one. Okay. Right? Note that the sum goes from element 2 to element N e L minus 1. Okay? So, that means, that we are looking at all the elements in between here, right? As contributing, the same sort of term. Okay? As I'm about to write out in this summation. Okay. So here, we get properly c 1 element e, c 2 element e. EA over h e. Our little matrix here, which gives us our element stiffness matrix, would be 1 minus 1 minus 1 1 And multiplying it here, are the degrees of freedoms d 1 e, d 2 e. And then, added on to this, is the very last, the very contribution, from the very last element, from element N e L, which we have above us here, in the figure. Right?  You know in the figure.And up here we see, that the contribution comes only, from That degree field. Okay? And in our global numbering system, right? Well, let's look at it, in our local numbering system, that is c 1 N e L. Right? Element N e L. Okay? Just as this, as far as c degrees of freedom were concern, was c 2, element 1. So, here we get c 1 N e L. Multiplying. E A Over h e. Okay? E A over h e, but now, it, this contribution from the So called stiffness contribution, from this element, it takes 1 to form 1 minus 1. And here, we get  it is multiplied by d 1 for element N e L, and d 2 for element N e L. Okay? And in a related manner, right. In a related manner, what we will see is that, what we obtain is that, as far as our force contributions are concerned, right? Which come only, from our forcing function, there being no traction condition here, w h f A d x equals. Okay. So just as before, we, we get a contribution c 2 1 f A h e over 2, okay? This would be the only contribution, right? From element 1. From the other elements, right? We will get a contribution, which has the same form as our main sum over all the elements, when we were doing the Dirichlet-Neumann problem. Right? This is the sum of e equals 2 to N e L minus 1. And multi, and here in this sum the, the contributions from the, from the degrees of freedom for weighting function c 1 e, c 2 e F A h e over 2. Okay? This thing now, will be multiplied by 1, and 1. And finally, from the very last element, we would get once again c 1 N e L. We would have f A h e over 2. Okay? These are the contributions, we would get. Right? And really this you know, if you go back, and look at our general Dirichlet-Neumann problem. What you will see is that, we are just accounting for, if you look at this term, right? If you look at how, we obtained This term. Right? You could go back, to the Dirichlet-Neumann problem, right? And look at what we had, for the very last element. And in there, simply set c 2 N e L, right? Equal to 0. Which should be like, setting the weighting function, corresponding to the second node of that element equal to 0. Okay? And this is what, you would be left with. And the same would apply, for this term here. Okay. If you were to do the same thing, in the force contribution. Right? So this is all, you would be left with.

\section*{ID: C5QsF96kCg8}
So. So we have this and now let's look at what the contributions are to our stiffness matrix and our force vector. What I'm going to do now, to do that, in order to get there is to simply carry out the process of assembly, right? Of these two equations, the last two equations on this slide of that and that. Okay? Recognizing of course that we have this map, right? So this map between local and global degrees of freedom. Okay? So what we do is we carry out now the process of finite element assembly. Okay? Recognizing that our vectors such as c1e, c2e, right, is equal to, is, is actually identically equal to our entry ce, ce plus 1. Right? And it's, and, and basically the same thing for the d vec, for the d degrees of freedom as well. Okay? So. In element e, d1e d2e, or d sub e and d sub e plus 1. Okay? These are local degrees of freedom. And these are global degrees of freedom. Okay. So, when we put all of this together, what will we get is is the following. Right. We get here, the matrix c, sorry. The row back to c2, c3, all the way up to cnel, multiplying EA over he. And I didn't state it explicitly, but you note that I have already fallen to using our our special case where all the element lengths are the same. Okay? All right. So we have that and now the matrix that we will have here will have the following form. We'll have minus 1 here, 2, minus 1, minus 1, 2, minus 1. Okay.  So this cnel corresponds to c1nel, right? In terms of local node numbering. And what we see is that this process essentially ends with a 1 here and a what, sorry. It's, there's a 1 on the diagonal here.  There is a 1 on the diagonal here, and a minus 1 here. Okay. This is multiplied by a column vector which is full. Right, there's nothing lost in this column vector for d degrees of freedom. Comes all the way down to dnel plus 1. Okay? This is equal to, we're going to write it down here just because I just need more room. We have, for the forcing vector, we have c2, c3, all the way up to cnel. Okay? Again using the, the special case of all the element lengths be the same, we have fAhe over 2. Okay, and now the contribution that we get here is of, of a sort where all the entries are 2. Okay. As far as the sizes are concerned, we note that this now has size nel, minus 1, right. It's clearly, if something is going from 2 up to nel, right? This now has length nel minus 1, okay? Whereas this vector has length nel plus 1. Accordingly, the dimensions of this matrix, right, are nel minus 1 rows, and nel plus 1 columns. All right. This is also nel minus 1 and therefore so is this nel minus 1.  Okay. All right, and here now that we're we are getting used to thinking about these kinds of ideas, we make the observation that d1 is now equal to u naught, right, using the kronecker delta property, right? Whereas dnel plus 1, which is the trial solution degree of freedom corresponding to the last node, which is the second Dirichlet boundary condition at x equals L. This is u given. And both these quantities are known. Okay? And also note that now that we have this form, recall that the other elements in this column vector which I am going to mark out in a step that is recommended only for clarity and not something that you should normally do in a matrix. All right we have right over here two. We have zeroes, right.  All the way up here. Well, it's a good thing I turned back to look at this matrix, because I realized that I had forgotten that in this very last element here, the one, I made an error, right. There is a contribution coming to that element or, or to that entry from the nel minus1 element. So that entry there, properly, is 2. Okay. If you just go, again, if you would go back and look at our contribution to the, to the eventual stiffness matrix from our Dirichlet, Nuemann problem, you would see that there is a two there. Right, I was simply forgetting the fact that there was an, an element before it. Right? Okay, so those are traps for the unwary. And for some reason I seemed to have introduced a 1 here. That's a 0. Okay. All right, so essentially the first column and the last column have a minus 1 in one position, right there, and zeroes. And the very last column has a minus 1 in the very last position and zeroes above it, okay? We recognize the fact that in the multiplication on the left-hand side of this matrix vector product that column vector multiplies u0, whereas this column vector multiplies ug. Okay? And since u naught and ug are known, we can move the to the right-hand side. Okay? We do that, and so what we're left with then is c2 up to cnel minus 1, multiplying EA over he. There's a matrix here which has the form 2, minus 1, minus 1, 2, minus 1, going all the way down to 2 here, and. Now we would have a minus 1 here and a minus 1 here. And just for completeness, let me put a 2 there, as well. This multiplies now. Now what we're left with here is a vector starting with d2 and coming all the way down as far as dnel. Okay? The first and last entries from the trial solution degrees of freedom vector have been lost, okay? But they haven't been lost forever. They've just moved to the right-hand side. And on the right-hand side, we have our c vector consists of starting with c2, going as far as cnel minus 1, okay. This multiplies, first fA over he, divided by 2. It multiplies the force vector now with entries 2 in every position. Okay? Additionally, it has EA over he, which is the contribution from the left-hand side right? Correct? The, the contribution that arises from the fact that our first and last nodes have Dirichlet boundary condition specified on them. Okay. So you get EA over he. And I realize I've given myself very little room there. So let me just move it to the next line.  Plus EA over he. Multiplying first, a column vector with the u naught in the first position, and zeroes everywhere else. 'Kay, and this is the contribution from the Dirichlet boundary condition at the left end, at x equals l, where we have the trial solution values specified to be equal to u naught. And then we also have EA over he multiplying a column vector which is zeroes everywhere, except in the very last position where it is ug. Okay. We close it here. Okay. Note that this parenthesis, this right parenthesis closes that left parenthesis. Okay?  Well now is before we act, you know, everything is the same as before. We have c transpose, right. This is our stiffness matrix K, which has dimensions nel minus 1 cross nel. Sorry, nel minus 1 cross nel minus 1. Okay? And this is our reduced d vector for this problem. Okay. These are the unknown nodal trial solution values. Okay? Once again here, we have our c transpose vector, and everything that multiplies it from that left parentheses, parentheses to the right parentheses forms our f vector. Okay. So we have once again, we have c transpose K d equals c transpose F. For all vector c, now belonging to a smaller dimension space Rnel, minus 1, okay? And then what this implies as before, K d equals F. Okay? Our final finite element equations to be solved. Okay? What I'm going to do now is just write out our final forcing vector in the finite element equations and note its contributions. All right, F is the force vector in this case. All right? Where it is equal to fAhe over 2 with entries 2 everywhere. Right. And this is the contribution from the forcing function. Right. Our function F. All right. Plus, EA over he multiplying u0 a column vector with u0 in the first entry and zeroes elsewhere, right? This one is the contribution from the Dirichlet forcing. Right, at x equals 0. Okay, of course, if u naught equal to 0, this thing would just drop out. Okay, plus EA over he multiplying a common vector with zeroes everywhere except in the very last position which is ug, which now is a Dirichlet data at  at x equals L. Okay? So here you have a situation where clearly having only Dirichlet boundary conditions is actually driving the problem, right? There are no Neumann data in this problem, purely Dirichlet. Okay, so this would be a good place to stop this segment.

\section*{ID: mBLzFl3DMJs}
There was an error in board work that I made on this slide and what I'm going to do right now is just fix it directly on the slide. The equation in question is this matrix-vector weak form. And it appears at the top of the slide right here. That's the equation we're going to fix. And the correction is a very small one fortunately. Here I denoted the, the index of this last entry as nel minus 1. That is incorrect. It should be just nel, so we excise the minus 1. Okay? And now when we go on to the right-hand side of the equation, it's the same thing. We get rid of that minus 1. Okay? So that index of the very last component is nel. Once we have that, everything else is correct and the equations on this slide are now fixed.

\section*{ID: DTW616pbd8A}
In this segment we are going to extend our development of basis functions in one dimension to higher order polynomial basis functions. Okay. So the topic of this segment is going to be. Higher order polynomial Basis functions. Having already developed the linear basis functions, we will do this in a sort of deductive manner by going first to the quadratic functions, developing them explicitly and then laying down a general formula for arbitrary order polynomial. Okay. All right. So, let me write that down. We'll start with quadratic basis functions. Okay so when one is talking about quadratic basis functions in for a one dimensional problem here is the setting. This is our domain of interest. And, this is 0 that point is L. Okay? And, we have our nodes, right? So let's suppose that these are our nodes. Okay? So that would be x1, x2, x3, so on. And now let's suppose that this is element omega e. Okay? It turns out, that just as linear 1d elements have two nodes, because we need essentially two degrees of freedom in order to interpret linears, in order to write out linear equation. And so it follows that quadratic elements in 1d have how many nodes? Three. Right? So if this is omega e, if you just follow the numbering system, what you will see is that the node numbers, the global node numbers here are x2e minus 1, x2e x2e plus 1. It continues, and, essentially ends with x twice nel for number of, elements. Plus one. Okay? That's the, the global number of the last node. All right. So this is the setting we have. We are going to take this element out here and develop basis functions for it, okay. So we have here our element sort of blown up. Well let's read, renumber the nodes here. Okay, so this is the the quadratic element in it's Physical domain. As we did for the case of the linear elements and linear basis functions, we will suppose that this physical element is created for us or is obtained through a map from a bi-unit domain which is the parent domain, right. In which, on which our coordinate is labeled c. And in terms of, of c, we have this middle node with coordinate c equals 0. We have c equals minus 1, and c equals 1. Okay? And you will notice that this is very much like our the case of linear basis function, except that we have this extra node in here, right located at c equals 0. We suppose, as we did in the case of linear elements and linear basis functions, that our physical element is obtained from map, from this domain. Okay. And essentially what we are going to do here is write out our basis functions and also you know, work out what they are, what they're going to be. Now, when, when one is working with quadratic basis functions, our trial solution over element e, is going to be written as a, as essentially it's an, an expansion over the basis functions for that element, right. In this case we have e which represents the local node number or the local degree of freedom number. Running over from one to number of nodes in the element right, and in this case, equals 3, okay. So we have NA, right. We know that it's a function of x, but really it is a function of x through c. Just as we did for the case of linear basis functions. Okay. We have this and it multiplies da sub e. Okay, da sub e being the, the actual, degree of freedom value, right, a scalar, which is being, interpolated, so to speak, by our basis function, NA. All right? Also, much as we did, in the case of, linear basis functions, we will write out wh, our, weighting function, as the same sort of representation right, a equals 1 to number of nodes in the element n a x also parametrized by c through our mapping multiplying cAe okay. And the question that we are going to address over the next few minutes is just how do we construct these Na's for the case of quadratic basis functions, all right. And here's how we do it. I'm going to write out the basis functions to begin with and then we'll talk a little more about them. We have N1 and I'm going to write it now directly, parameterized by c, though we know we get to c Through x and through the mapping and so forth. Okay. N1 is c times 1 minus c divided by 2. N2 is 1 minus c squared, N3 is c times 1 plus c divided by 2. All right? You observe, of course, that these are clearly quadratic in c. It's useful to plot them up, just as we've done for the linear basis functions. And, the way I'll do it is the following. I will suppose that this is the point, c equals minus 1. C equals 0 and roughly there should be c equals 1. All right, this is of course c. All right, if here I give you the value one. All right. The very first one of them is, the following, okay? I'm drawing N1. Right? It's quadratic, okay? That's N1. To draw N2 let me try to use a different color. Just for visibility. Okay. N2 takes on the shape, Of a quadratic function. Looking like that, okay? It's meant to be symmetric. I didn't quite get it symmetric, but it is meant to be symmetric, right? And this is N2. All right, and finally we have N3, which is the following. Okay, that's N3. All right. So those are our three basis functions in the case of quadratics. Something to note about them is the following, right? If we denote c1 equals minus 1, c2 equals 0 and c3 equals 1 to be the actual values of c at the 3 nodes in the sparing domain. What you observe is that the chronicle delta property holds, right? NA cB, Na valuated at cB equals delta AB. Okay? The same chronicle delta property that our linear basis functions possess. All right. And then there is this other property, which is that sum over A, NA at some, any, at an arbitrary value of c, the sum equals 1. Okay? And this is the property that is important in order to be able to represent constant functions, okay? All right. So we have these two properties for our basis functions, just as we saw these properties in the case of linears. Right. What we will do from here is make the observation that this sort of expression, right, the expressions that we've used here to write out the quadratics, actually, are routine from a more general expression that holds for this family of Lagrange polynomials, all right? And we'll approach it by writing out the general formula for Lagrange polynomials and recovering the quadratics as a special case. Right. Okay, so higher order basis functions. To generate higher order basis functions, we fall back upon the Lagrange polynomial formula, okay? So higher order basis functions are generated by the formula for Lagrange polynomials, Lagrange polynomials. Okay? Let's suppose that we're looking at basis functions of some order, and let's denote that order is Nne. Okay. Let's suppose that we have Nne order polynomials. And you see how this works, right? Why does it work to always say that we have Nne order polynomials? Because of course, that is the number of nodes in a single element. All right, Nne. Okay. Here's how it works. So, so what we're looking at now is a single element, okay? This is all omega e, and it has some arbitrary number of nodes, okay? Right, so the local node number in here would be, local node one. And that would be local node number Nne, okay. This, this is the sort of situation we are looking at. Okay. In this setting again, we're seeing that this element comes to us from a parent domain. Where likewise we have the same number of nodes in this parent domain as well. Okay. That's node one. That's node Nne. We will denote the coordinate in that parent domain as c, right? It is a bi-unit domain again, and that is seen by the fact that c here equals minus 1. And here we have, c equals One, right. Therefore, by unit because the total length is two. All right. In this setting, here is how we write out the polynomials. NA in terms of C is the following. It is the product B=1 to number of nodes in the element. However, B can not be equal to A. Okay, where a is what we have on the left hand side. Okay, we have here c minus cB, right? And this thing is divided by another product, the limits of which are the same. But here, the expression we have is cA. Minus cB. All right, that's it. Okay. And this holds now for A=1 up to the number of nodes in the element. All right. Let's check this out in fact let's check it out not for quadratics, but actually for an even simpler class of basic functions for the linears. Okay? So let's do that now. So. Okay. In the case of Linears, let's just recall one thing before we go onto the case of linears. If you look at that element that we had. And we look at it in the, parent domain, Omega of C. Right, we have, this is equal to, this is -1, right? C=-1, C=1. All right? What we're seeing here is that when we label the c's as ca, cb, and so on, we did that right here, I just pulled up the previous slide, you see that ca and cb and so on, that we're use in our formula at the bottom of the slide, okay? Here's what they are. This is the point C one That is the point C N and E. And inside here, we may have cA, cB, right? And those would take on the actual values of C at those points. Okay, so with this setting, all right for linear's. We have just two of them, right. Just two of those node points. So in this domain, we have c1 equals minus one, c2 equals one. Right? So let's construct our polynomials from this formula. N1 is going to be the product B equals 1 to which is 2, right? Because for linears, we know that number of nodes in the element Is 2, okay? However, b cannot be equal to a. On the left-hand side, we have a=1. Right here, right? So we're saying b goes from 1 to 2, but b cannot be equal to 1, okay? And here, we have c minus cB divided by the produce over the same limits. C1 with that which was cA equals one of the left-hand side, of course, minus cB. Let's work this out in greater detail. So the numerator is, is has a single term in the product. It is c minus cB. We look at the limits here. B goes from 1 to 2 but B cannot be equal to 1 so B has to be equal to 2. And in the denominator again, we have c1-c2. Well this is c-c2? What is c2? it's right here, correct? It is one, divided by c1-c2. C1 is minus one, c2 is one. We get back one minus c over 2. Kay? Which we recognize to be N1 for the linears. Taking the same sort of approach, what you will find is that n2, c equals the product probably don't have quite enough room here, so let me go the next slide. N2, c equals product B equals 1 to 2. Now B-Not equal to 2. Here we get c minus cB. Divided by the product over the same limits. CA, which in this case is 2, minus cB. Okay? And in those limits, we recognize the only value b is allowed to take is 1. So when we work this out, we get c Minus, C-1. C-1 however is minus one. Divided by c2 which is one minus cB which is minus one. Okay. And we get one plus c over two which we also recognize to be N2. For linears. Right? So here we see that our formula works out very well for linears, it works out for quadratics, which you can check out, and it also does work for high order polynomials. Right? This is a good point to end this segment.

\section*{ID: zzpiN8vWqQo}
I had made an error in board work on this slide. It is, right where I started talking about the order of the one monomial basis functions in each element. On the slide, I indicated that the order of the polynomials is N any, well that it is N any, it is actually N any, minus 1. So the place where the error appeared is right here, and that should appear as N any, minus 1. Okay. That is the order of the polynomials, and the idea is that if we are working with linear elements we'd have, two nodes in there. Right? So number of nodes would be two. But the order of the polynomial would be one. The order of the polynomial basis function would be one. So that would be 2 minus 1, which is 1. Okay? That fixes this slide and the rest of it works fine.

\section*{ID: Vi-EwmYfWk0}
Welcome back. In the previous segment we looked at how to construct quadratic basis functions for quadratic elements, and also pushed ahead to high order basis functions, right? For high order elements. The formula for higher order basis functions is obtained from the Lagrange polynomial formula. All right and we saw all of that. Just a couple of points I want to make about the Lagrange polynomial formula, and here are those points. So first of all the Lagrange polynomial formula or the Lagrange polynomials themselves. Right, they satisfy the Kronecker delta property which our basis functions have possessed. Okay, so the general formula also satisfies this Kronecker delta property and I just want to demonstrate that. So the Lagrange polynomials satisfy. This Kronecker delta property. Okay? Let's check it. So, you recall that if we have, an element with, Nne nodes we have this formula for the eight of those, basis functions, right? NE of xi we found is, the product B going from 1 to number of nodes in the element, B not equal to A. xi minus xi B divided by a product with the same limits. But, the, the, term that we're multiplying here is xi A minus xi B. Okay, so let's check this out, right. And this holds, of course, for A equals 1 to number of nodes in the element. Right. Let's check this out. So we know that from the Kronecker delta property, if we have NA, xi A, right, just substituting xi equals xi A in the formula above, we see very clearly that NA xiA, equals pi. B equals 1 to number of nodes in the element. B not equal to A. xi A minus xi B Divided by pi, B equals 1 to number of nodes in the element. B not equal to A. Again xi A minus xi B. Right, so therefore, this is, indeed, 1. Right? Which is what one would expect from the the Kronecker delta property, right? NA of xi A should be equal to 1. All right? Let's see what happens if we take a, well if we evaluate xi, at some other value of, at some other position in the, in the element in the parent domain. Okay, so, in particular let's suppose N, we evaluate NA, not at xi A, but at sum xi C, all right? Where, of course, we are saying here that C is not equal to A. Okay? So, we have the product, B equals 1 to number of nodes. Not equal to A. Here we have xi C minus xi B. Right, remember that's a product, right, of all those sorts of terms. Divided by another product, same limits. B not equal to A here. We get xi C, minus, sorry, here we get xi A minus xi B, okay. And now you see what happens right? In the numerator the product runs over B equals 1 to Nnee but B not equal to A. However, for C not equal to A what we observe is that for one of these terms does take on the value xi C itself, right, because xi B is equal to xi C. And that's what sets this u, expression to 0. Okay? So we get here 0 when C is not equal to A. All right? So the Kronecker delta property does indeed check out. It's a simple enough exercise for you to check that the other property holds. All right? So, check that, now sum over A, NA, at any value of xi, is equal to 1, okay? Using the Lagrange polynomial formula. Okay. Check this out as an exercise. All right. So, having looked at those two properties, let's move on. But now, let's try to develop our, equations, our finite element equations, our finite element formulation, for the case of quadratic basis functions. Okay? So, what we will do now is develop the finite element formulation. With quadratic. Basis functions. All right? And we will take this up directly in the finite dimensional weak form. All right, and specifically we're going to take it up in the finite dimensional weak form where we've already Introduced the notion of the partition into elements. Okay, so we have sum e going from 1 to number of elements, integral over omega e. W h comma x sigma h A dx, and we recall that sigma h is what? Sigma h is given to us through the constitutive relation which is E times u h comma x, right? This is equal to sum e equals 1 to Nel, integral over omega e, Wh f A dx plus. Let's suppose we're dealing here, and in fact let us deal with the, Dirichlet-Neumann problem. So, we get our traction term, or our, Neumann boundary term, Wh, t bar A. Okay? And I should mention that here we have the Dirichlet-Neumann problem problem. Two questions, what other kind of problem could we consider? Correct, we could consider the Dirichlet-Dirichlet problem. Another question, why do I say that this is a Dirichlet-Neumann problem? Where does that show up? Right, it shows up in the fact that this is the Neumann boundary condition. Okay? The Dirichlet condition is, of course, already embedded in our spaces. All right. So this is the problem we are looking at, and, let us now focus on this term. Okay, this left hand side integral over the element. Right? Okay. So, let's consider integral over omega e. Wh comma x we have sigma h, but let us directly use our constitutive relation here. We have E u h comma x, and I've left a little space here, because I want to introduce the area in there. Right? dx. Now, how are we going to write this out? Okay. In order to write this out we need to express our gradients. Okay? Right. And in order to express our gradients what we will do is we will recall, as we've done before, that u h comma x. It isn't element E, because we are talking of integrating only over element, over the domain omega e. But I'm going to save ourselves the writing of that extra subscript here. Okay, so I'm just going to write it as u h comma x. This is, sum A going from 1 to number of elements, but we're working with quadratics here. Right, so we have A going from 1 to 3. NA, and you'll recall that just as we did before, we are going to calculate this gradient by taking the gradient of the basis function, okay? And a similar sort of expression for the waiting function. Okay? Where we may further ask well how do we compute these gradients? The change rule is the answer. Right? So the way we would right NA comma x is NA comma xi, which is easy to do because our basis functions are indeed parametrized by xi. All right, this times xi comma x. Okay? So, having written out or having recalled how we are going to write out our gradients, right? The only difference here between with respect to what we did for the linear problem is that we need to sum over three basis functions now because we're doing quadratics. Okay, so the way we will use this is by writing this as an integral over omega e. Now for Wh comma x I'm going to write sum A going from 1 to 3, NA comma x, but we already know NA comma x is NA comma xi. xi comma x. CAe. All of this represents Wh comma x. Multiplied by EA, multiplied again by sum over B going from 1 to 3. NA comma x, but again we are going to use our change rule. It's not A, it's B here, because we are summing over B. And B comma xi, xi comma x, dBe, okay? dx. That is how we're going to compute that element integral, right? Okay then, let's see what else we can do about this. Let's, let's start out by computing each of these quantities, 'kay? The computation of xi comma x takes a little more preparation, as we know from before. And we'll postpone that for just a few minutes. All right, so let's start out here. N1 comma xi is d d xi of N1, but N1, we remember, is one-half xi times 1 minus xi. Okay? It's that derivative, all right? Which is dd xi of one-half, xi minus xi squared, okay? Which we see is one-half times 1 minus 2xi. N2 comma xi is dd xi of 1 minus xi squared, which is d, which is, well this is easy to do, I don't need another step here. This is just minus 2xi. And finally N3 comma xi equals dd xi, of one-half xi times 1 plus xi. And when we carry this out, we get one-half 1 Plus 2xi. All right? Straightforward enough. Now, what about xi comma x? What about computing this term?

\section*{ID: EkIH8eorBjg}
Can you recall how we did in the case of linear basis functions? Right, in order to do that, we take the following approach. Right? We use the invertibility of our mapping. Okay, and what is the mapping we're talking about? It is the fact that the geometry is mapped as follows, right? x over element e is also written, parameterized by the coordinate in the parent bi-unit domain, right? And the way we do this is to actually use the same basis functions as we use for our trial solution and waiting function, right? So we have NA parameterized by xi times xAe, and you record what these are. What are they? Right, they are our nodal coordinates. In the physical domain, or physical space. Right, and this is the fact of the isoparametic mapping. 'Kay,isoparametric, because we are using the same parameterization for the trial solution and waiting function, as well as for the geometry, right? 'Kay, what that lets us do is the following, right, what this implies for us is that over element e, we have x,xi is now sum A going from 1 to 3, NA,xi times xi, sorry, xAe, right? But, just on the previous slide, we have computed NA,xi for A equals 1 to 3. Right, there it is at the bottom. Right, the last three equations. So, let's use those. We get here. Iâ€™m going to write out the sum explicitly, 'kay? We have N1,xi, xi 1e plus N2,xi, xi 2e plus N3,xi, xi, sorry, x3e. We have N1, N2 and N3 derivatives with respect with xi. So that turns out to be one-half 1 minus 2 xi times x1e minus 2 xi times x2e plus one-half, 1 plus 2 xi times x3e. All right, now what I'm going to do is note that there are just two constant terms here that is terms independent of xi, and those are the ones. I'm going to pull those constant terms aside first. x3e minus x1e divided by 2. The other terms depend upon xi, okay? And those terms are the following. I have, from here multiplying x1e, I have let me see. I'm going to write all of this as a, as multiplying xi. Right, because the only other term is linear since we take the derivative of a quadratics. All right, for x1e, if we just look at that second to last line, we get minus x1e. For x2e, we get minus 2x2e, and for x3e we get plus x3e, okay? I'd see that I may have made a algebraic error on the previous slide so let me just go back here, right. If I look at our quadratic basis functions, I observe that I have xi times 1 minus xi. I really need to have a negative sign inside of this. Okay, so I need to have a negative sign here. Okay, that works out now, and then what happens here is that I pick up a negative sign here as well, and when this all works out, these, the sign changes as follows, okay, all right? That is right now, and then when I come back here, the signs here change, okay? All right, now everything works out fine. So this becomes plus, okay. That matters to get things right because we need to examine what happens with this term here, okay? And, in order to examine what happens with it, let us look at our element more closely. We have omega e, a quadratic element, right? Or, alternately, a three node element with quadratic basis functions, right? The, the midside node, right, the, the node between x, let's say x1e, x3e and x2e, right, that node, remember is obtained from a mapping, that node or indeed the entire element is obtained from a mapping from a bi-unit parent domain, in which the coordinates of xi equals minus 1, xi equals zero, and xi equals 1, right? What that means is that x2e is the midside node, implying that the position of x2e is x, the position of x3e plus the position of x1e, divided by 2. If it is a midside node, that must hold, right? But then, this implies that in our expression for x,xi equals x3e minus x1e divided by 2 plus xi times x1e minus 2x2e plus x3e. We see that this is equal to 0, okay, because of that result. On the other hand, this is what we can now once again denote as he over 2, right, because he is the length of the element, right, which is just the distance between the last node on the element and the first node on the element, which is x3e minus x1e. If one just looks at that figure again, okay? What this tells us then is that because of the invertibility of the map, 'kay, the fact that this map is invertible. 'Kay, implies that xi,x equals 1 over x,xi, 'kay? That's what invertibility tells us, 'kay, which is just 2 over he. So we have a very straightforward way to compute our gradients, all right? What we're seeing is that even though we have quadratic elements, the essentially the element length, right is still given of course by the distance between the last node and the first node, okay? And indeed even our so-called tangent of the map, which is x,xi, right, it remains equal to he over 2, which is a constant, right? So what we're saying is that the tangent of the geometric map. Is constant. Right? This follows because the mapping that we have is also what is called an affine map. 'Kay? Right, so with all of that in place, what we observe is that now, we have a very straightforward approach to computing this integral, 'kay? So integral over omega e wh,x EAuh,xdx now is integral over omega e. Sum over A, NA,xi, xi,x, but xi,x we've just concluded is 2 over he times cAe, and this is how we write wh,x, we get EA, and for uh,x, we have sum over B, NB,xi, xi,x once again is written as 2 over he, dBe dx, okay? We're essentially able as we did in the case of the linear based functions, to reduce our gradients to gradients in terms of xi. And therefore we're able to express this as entire integrant in terms of our coordinate and the parent bi-unit domain which is xi. All right this is a good place to end this segment. When we return, we will proceed with computation of the other parts of our finite dimensional weak form.

\section*{ID: 6aq8dkuJrz0}
All right, in the previous segment we figured out how to go around computing how to go about computing the the gradients, right, which go into our integrals. So let's pick up there and complete the evaluation of this integral. And you will recall that the integral we were working with is the following. Integral over omega e, w h, x. EA, u h, x dx. And using what we developed in the previous segment we know that we can write this as sum over for integral over omega e Let me see, we can write it out as sum over A. N A, C, C, X, which is two over h e, times C A e. All of that is w h, x multiplying E A. Times sum over b and b, c. C, X for which we again use two over h e. D E, D B E sorry. D X Okay. But note that for d x we could write it as d x. D ksi, d ksi. All right, and we know that d x d ksi is just x, ksi, which is what we computed in the previous segment to be h e over two. Even for quadratic basis functions. And this comes about from the from the fact that we have an affine map. It also has to do with the fact that Lagrange polynomials are complete. Okay? All right. So, we have this representation and now we can write out this integral in an even simpler form. We are going to note that because of the fact that we have h e over 2 here, this cancels out with that, okay? And we can now write out this integral. Using what we call matrix vector notation. Okay? And in order to use matrix vector notation. Let's, let's actually set it up a little more carefully, okay? We will use matrix net vector notation but let's do, do just one step before it which is a step we've taken when we were working with linear basis functions. And that is to recognize that c a e d b e's are independent of c. And so too is this product E A of constants and this remaining two over h e. Since your independent of position they, can be pulled out of the integral. Okay, right so we're getting up to using major vector notation but before we get before we actually do it lets write that integral as a sum over A and B of the following quantity we can actually pull even E A out of that summation right, so we can have 2 E A over h e sitting outside the summation, okay? And then we have the sum over A and B, c A e, right? Integral over. Well, we'd, we'd written it up here as an integral over Omega e, but using this chain rule right there, we observe that we can actually write that integral as an integral over. Over what? Over a different domain right, right its all omega C. Okay. Now the integrant is a simple one it is N A comma C and B comma C okay, d ksi. All right. And, I'm going to put parenthesis on this integral just to make it clear that it's that's where the integral ends. And then, here we have dBe. Okay? The use of matrix vector notation as you will recall from our development of the method for linear basis functions the use of matrix vector notations comes in to relieve us of the need to have this explicit sum. Okay? So, now using matrix vector notation here is what we get. The, that sum over A can be replaced by the sum over A can be replaced by C 1 E, C 2 E, C 3 E. With these being the degrees of freedom that interpret the weighting function in element e. We get 2 E A over he. Right. We get our integral, right. However, each, we, we, we get a bunch of integrals. Each of which, is one component, of a matrix. Right here we get integral, over Omega C of N 1 comma c and 1 comma c. However, the integral over on the N 1 comma c, I'm going to write explicitly as an integral from minus one to one over c, all right, because that is the extent of our bi-unit domain. So here I get n1 comma c and 1 comma c, d ksi. The second position I get integral minus one to one and one comma z and two comma z. And the third position the One 3 component of this matrix. I get integral of N 1 comma C. N 3 comma xi. All right? Here I get integral minus 1 to 1 N2,xi N2,xi d xi and here I get integral minus 1 to 1, N2,xi, N3,xi d xi, and here I get integral minus 1 to 1 N3,xi N3,xi d xi. What about the rest of the matrix? Right, it's symmetric. All right? So, multiplying all of this, I have here Instead of the dBe, I have those represented as d1e, d2e, d3e. Okay, so this is our matrix vector nota, or representation of our left-hand side integral over an element for quadratic basis functions. What we're going to do next is actually explicitly calculate those integrals. All right, so. So integral minus 1 to 1, N1,xi N1,xi d xi equals integral minus 1 to 1, let's see. It is let me just check what that integral eh, what that derivative is. That derivative is 2 xi minus 1 time the whole square d xi, right, d xi minus 1 is N1,xi, okay? All right so we get here for this integral, we get, this is integral, the integral minus 1 to 1, 4 xi squared minus 4 xi ma, plus 1 d xi, and observing that this is an integral from minus 1 to 1, we know that the odd terms don't survive the integral. All right, it's only the even terms that survive. When we do this we get 4 xi cubed over 3 plus xi limits minus 1 to 1, okay? This is 4 over 3 plus 1 minus minus 4 over 3 minus 1, right, which is 2 times. 7 over 3. Let me just check this out. Hm,  N1,xi, all right there is a one-quarter here, okay, that's because N1,xi is one-half of 2 xi minus 1, so we get a one-quarter here. We also get a one-quarter here, one-quarter here. Right, and we get a fourth here. So, when we carry this out, we get 7 over 6, right, which is what I was expecting. All right, now integ, the next term over, right, my integral, minus 1 to 1, N1,xi, N2,xi d xi. This is integral minus 1 to 1, N1,xi, we know's one-half times 2 xi minus 1. And 2 xi as we saw from before is minus 2 xi, okay? Integral over d xi versus then one-half integral minus 1 to 1, okay? What do we get here? We get here 2 xi minus 4 xi square, okay, d xi, which is one-half. Once again we don't need to compute the odd term, right? We compute only the even term, we get one-half let's pull the minus sign out, we get minus one-half times 4 xi cubed over 3, limits minus 1 to 1, all right? And this turns out to be. Minus two-thirds times 2, which is minus 4 over 3, okay? All right, moving on, integral minus 1 to 1, N1,xi, N3,xi d xi is integral minus 1 to 1 one-half 2 xi minus 1 times one-half 2 xi plus 1, d xi, 'kay? This is one-fourth integral minus 1 to 1, 4 xi squared minus 1, d xi, which is one-fourth times 4 xi cubed over 3 minus xi. The limits on this are minus 1 to 1, okay? Let me actually use square brackets here as I did previously. Which is now one-fourth. Times 8 over 3 minus 2, which is 1 over 6, if I'm not mistaken. Yep, right. Okay carrying on, let's just move onto the next slide here. So, the next term we need to calculate is integral 1 to 1, N2,xi, N2,xi d xi, which is integral minus 1 to 1, N2,xi is minus 2 xi, and we get the whole square here, right? And, this is an easy integral to carry out. It is just 4 xi cubed over 3, limits minus 1 to 1, which gives us 8 over 3. All right, integral minus 1 to 1, N2,xi, N3,xi d xi. All right, that's the 2,3 term of the, 2,3 component of the matrix. This is integral minus 1 to 1, minus 2 xi times 2 xi plus 1 d xi, which when we carry it out is integral minus 1 to 1. Let me see what do we get here, we get a minus 4 xi squared minus 2 xi, d xi, which is oh, as I've been doing often in this calculation, I'm missing a half here. So I get a half here. Okay, so that is one-half again using the fact that it's only the even terms that survive, we get minus 4 xi cubed over 3 minus 1 to 1, and when we go ahead and compute this we get minus 4 over 3. The very last term to be computed here is the integral minus 1 to 1, the very last component is integral minus 1 to 1, N3,xi N3,xi d xi, which is the integral minus 1 to 1. We pick up 1 over 4 and here we get 2 xi plus 1, the whole square, right, and that is because N3,xi is just one-half 2 xi plus 1, all right, so here we get 1 over 4, integral minus 1 to 1 4 xi squared plus 4 xi plus 1, d xi, right, one-fourth 4 xi cubed over 3 plus xi. And of limits of the integration are minus 1 to 1. And when we compute this we get one-fourth of eight-thirds plus 2. Which is right, 7 over 6. All right, excellent. Now, collecting results, what we get is the following. We set out to compute integral over omega e wh,x, sigma hAdx. Upon first substituting the constitutive relation for sigma h, then using our basis functions to write out the fields and their gradients and then going ahead and doing the computation, right, do, doing an explicit integral over xi, integration over xi, we get the following. We get, c1e, c2e, c3e, right, which is our vector representation of the nodal degrees of freedom of the weighting function, okay? 2EA over he, and here we get our matrix which we've just computed, and we've just computed it to be 7 over 6, minus 4 over 3, 1 over 6, 8 over 3, minus 4 over 3, 7 over 6. It's symmetric, but now let's just explicitly fill it in just this time. And for our matri, our vector representation of the nodal degrees of freedom of the trial solution, we have d1e, d2e, d3e. Okay, now as we observed before for the case of linear basis functions and linear elements, right, two-noded linear elements, this is what we will denote as Ke, right, our element stiffness matrix. All right, this would be a great place to end this segment.



\end{document}